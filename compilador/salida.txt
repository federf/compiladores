*********************************************************************************** 
**                                                                               ** 
**                            Corriendo casos de prueba . . .                    ** 
**                                                                               ** 
**                                                                               ** 
*********************************************************************************** 
     
     
///////////////////////// TESTS CORRECTOS ////////////////////////////////////////
---------------- Test tests/test_correctos/factorial.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -28
OFFSET = -36
OFFSET = -48
OFFSET = -52
OFFSET = -64

parseo exitoso
tamaño lista de codigo tercetos: 26
lista: 
{LABEL, null, null, Result: BeginMethod factorial}

{METHODDECL, Metodo{ name=factorial, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=n, value=null, size=0}]}, null, Result: null}
{ASSIGN(=), 0, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel2}
{ASSIGN(=), 1, null, Result: VarLocation{name=total, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel5}
{GE(>), 0, 0, Result: VarLocation{name=GELabel7, type=boolean, expr=0 > 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel9}
{CMP, VarLocation{name=factorLabel8, type=boolean, expr=VarLocation{name=GELabel7, type=boolean, expr=0 > 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel10}
{MULTIPLY(*), 0, 0, Result: VarLocation{name=MULTIPLYLabel13, type=int, expr=0 * 0, size=0}}
{ASSIGN(=), 0 * 0, null, Result: VarLocation{name=total, type=int, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel15}
{MINUS(-), 0, 1, Result: VarLocation{name=MINUSLabel17, type=int, expr=0 - 1, size=0}}
{ASSIGN(=), 0 - 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel9}
{LABEL, null, null, Result: EndWhileLabel10}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod factorial}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 3, null, Result: IntLiteralLabel19}
{METHODCALL, factorial, 1, Result: RESULTLabel21}
{PARAM, null, null, Result: 3}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=factorial, args=[3]}]}, null, Result: EXTERNINVKLabel23}
{LABEL, null, null, Result: EndMethod main}



.globl	factorial
.type	factorial, @function 
factorial: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    mov 0(%rbp), %eax
    mov -4(%rbp), %eax

    movl $1, IntLiteralLabel2(%rbp)

    mov 1(%rbp), %eax
    mov -12(%rbp), %eax

    movl $0, IntLiteralLabel5(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -28(%rbp)

.BeginWhileLabel9

    mov true(%rbp), %eax
    cmp -32(%rbp), %eax

    jne EndWhileLabel10

    mov $0, %eax
    mov $0, %edx
    imul %edx, %eax
    mov %eax,-48%(ebp)

    mov 0 * 0(%rbp), %eax
    mov -36(%rbp), %eax

    movl $1, IntLiteralLabel15(%rbp)

    mov $0, %eax
    mov $1, %edx
    sub %eax, %edx
    mov %edx,-64%(ebp)

    mov 0 - 1(%rbp), %eax
    mov -52(%rbp), %eax

    jmp BeginWhileLabel9

.EndWhileLabel10

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $3, IntLiteralLabel19(%rbp)

    call factorial
    movl %eax, RESULTLabel21(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel23(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/floatTest.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -12
OFFSET = -12
OFFSET = -12
Error: Method mult must return float
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -24
OFFSET = -32
OFFSET = -68

parseo exitoso
tamaño lista de codigo tercetos: 47
lista: 
{LABEL, null, null, Result: BeginMethod div}

{METHODDECL, Metodo{ name=div, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=a, value=null, size=0}, Simbolo{type=float, name=b, value=null, size=0}]}, null, Result: null}
{DIVIDE(/), 0.0, 0.0, Result: VarLocation{name=DIVIDELabel3, type=float, expr=VarLocation{name=factorLabel1, type=float, expr=0.0, size=0} / VarLocation{name=factorLabel2, type=float, expr=0.0, size=0}, size=0}}
{RETURN, null, null, Result: VarLocation{name=factorLabel1, type=float, expr=0.0, size=0} / VarLocation{name=factorLabel2, type=float, expr=0.0, size=0}}
{LABEL, null, null, Result: EndMethod div}
{LABEL, null, null, Result: BeginMethod resta}

{METHODDECL, Metodo{ name=resta, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=a, value=null, size=0}, Simbolo{type=float, name=b, value=null, size=0}]}, null, Result: null}
{MINUS(-), 0.0, 0.0, Result: VarLocation{name=MINUSLabel6, type=float, expr=0.0 - 0.0, size=0}}
{RETURN, null, null, Result: 0.0 - 0.0}
{LABEL, null, null, Result: EndMethod resta}
{LABEL, null, null, Result: BeginMethod sum}

{METHODDECL, Metodo{ name=sum, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=a, value=null, size=0}, Simbolo{type=float, name=b, value=null, size=0}]}, null, Result: null}
{PLUS(+), 0.0, 0.0, Result: VarLocation{name=PLUSLabel9, type=float, expr=0.0 + 0.0, size=0}}
{RETURN, null, null, Result: 0.0 + 0.0}
{LABEL, null, null, Result: EndMethod sum}
{LABEL, null, null, Result: BeginMethod mult}

{METHODDECL, Metodo{ name=mult, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=a, value=null, size=0}, Simbolo{type=float, name=b, value=null, size=0}]}, null, Result: null}
{MULTIPLY(*), 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel12, type=int, expr=0.0 * 0.0, size=0}}
{LABEL, null, null, Result: EndMethod mult}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{null, 1.234, null, Result: FloatLiteralLabel13}
{ASSIGN(=), 1.234, null, Result: VarLocation{name=x, type=float, expr=null, size=0}}
{null, 27.5, null, Result: FloatLiteralLabel15}
{UNARYMINUS(-expr), 27.5, null, Result: VarLocation{name=UNARYMINUSLabel17, type=float, expr=-27.5, size=0}}
{ASSIGN(=), -27.5, null, Result: VarLocation{name=y, type=float, expr=null, size=0}}
{null, 70.3, null, Result: FloatLiteralLabel18}
{UNARYMINUS(-expr), 70.3, null, Result: VarLocation{name=UNARYMINUSLabel20, type=float, expr=-70.3, size=0}}
{ASSIGN(=), -70.3, null, Result: VarLocation{name=z, type=float, expr=null, size=0}}
{METHODCALL, sum, 2, Result: RESULTLabel23}
{PARAM, null, null, Result: 0.0}
{PARAM, null, null, Result: 0.0}
{METHODCALL, div, 2, Result: RESULTLabel27}
{PARAM, null, null, Result: 0.0}
{PARAM, null, null, Result: 0.0}
{METHODCALL, mult, 2, Result: RESULTLabel29}
{PARAM, null, null, Result: MethodCallExpr{name=sum, args=[0.0, 0.0]}}
{PARAM, null, null, Result: MethodCallExpr{name=div, args=[0.0, 0.0]}}
{UNARYMINUS(-expr), 0.0, null, Result: VarLocation{name=UNARYMINUSLabel32, type=float, expr=-0.0, size=0}}
{METHODCALL, resta, 2, Result: RESULTLabel34}
{PARAM, null, null, Result: -0.0}
{PARAM, null, null, Result: 0.0}
{METHODCALL, sum, 2, Result: RESULTLabel36}
{PARAM, null, null, Result: MethodCallExpr{name=mult, args=[MethodCallExpr{name=sum, args=[0.0, 0.0]}, MethodCallExpr{name=div, args=[0.0, 0.0]}]}}
{PARAM, null, null, Result: MethodCallExpr{name=resta, args=[-0.0, 0.0]}}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[StringLiteral{value="anidandoFloatTest"}, MethodCallExpr{name=sum, args=[MethodCallExpr{name=mult, args=[MethodCallExpr{name=sum, args=[0.0, 0.0]}, MethodCallExpr{name=div, args=[0.0, 0.0]}]}, MethodCallExpr{name=resta, args=[-0.0, 0.0]}]}]}, null, Result: EXTERNINVKLabel38}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)


.globl	div
.type	div, @function 
div: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

DIVIDE(/)

    mov VarLocation{name=factorLabel1, type=float, expr=0.0, size=0} / VarLocation{name=factorLabel2, type=float, expr=0.0, size=0}(%rbp), %eax

    leave
    ret



.globl	resta
.type	resta, @function 
resta: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp


    mov 0.0 - 0.0(%rbp), %eax

    leave
    ret



.globl	sum
.type	sum, @function 
sum: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp


    mov 0.0 + 0.0(%rbp), %eax

    leave
    ret



.globl	mult
.type	mult, @function 
mult: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp


    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1.234, FloatLiteralLabel13(%rbp)

    mov 1.234(%rbp), %eax
    mov -4(%rbp), %eax

    movl $27.5, FloatLiteralLabel15(%rbp)


    mov -27.5(%rbp), %eax
    mov -12(%rbp), %eax

    movl $70.3, FloatLiteralLabel18(%rbp)


    mov -70.3(%rbp), %eax
    mov -24(%rbp), %eax

    call sum
    movl %eax, RESULTLabel23(%rbp) 

PARAM

PARAM

    call div
    movl %eax, RESULTLabel27(%rbp) 

PARAM

PARAM

    call mult
    movl %eax, RESULTLabel29(%rbp) 

PARAM

PARAM


    call resta
    movl %eax, RESULTLabel34(%rbp) 

PARAM

PARAM

    call sum
    movl %eax, RESULTLabel36(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel38(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/logicTest.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20
OFFSET = -32
OFFSET = -36
OFFSET = -48
OFFSET = -52
Error: Method pruebaLogica must return int

parseo exitoso
tamaño lista de codigo tercetos: 19
lista: 
{LABEL, null, null, Result: BeginMethod pruebaLogica}

{METHODDECL, Metodo{ name=pruebaLogica, return_not_void=true, typeReturn=int, parameters [Simbolo{type=boolean, name=b, value=null, size=0}]}, null, Result: null}
{null, true, null, Result: BoolLiteralLabel1}
{ASSIGN(=), true, null, Result: VarLocation{name=bool, type=boolean, expr=null, size=0}}
{null, false, null, Result: BoolLiteralLabel3}
{OR(||), false, false, Result: VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0}}
{null, true, null, Result: BoolLiteralLabel8}
{NON(!), true, null, Result: VarLocation{name=NONLabel10, type=boolean, expr=!true, size=0}}
{AND(&&), VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0}, !true, Result: VarLocation{name=CONJUNCIONLabel11, type=boolean, expr=VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0} && !true, size=0}}
{NON(!), false, null, Result: VarLocation{name=NONLabel14, type=boolean, expr=!false, size=0}}
{AND(&&), VarLocation{name=CONJUNCIONLabel11, type=boolean, expr=VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0} && !true, size=0}, !false, Result: VarLocation{name=CONJUNCIONLabel15, type=boolean, expr=VarLocation{name=CONJUNCIONLabel11, type=boolean, expr=VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0} && !true, size=0} && !false, size=0}}
{LABEL, null, null, Result: EndMethod pruebaLogica}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, true, null, Result: BoolLiteralLabel17}
{METHODCALL, pruebaLogica, 1, Result: RESULTLabel19}
{PARAM, null, null, Result: true}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruebaLogica, args=[true]}]}, null, Result: EXTERNINVKLabel21}
{LABEL, null, null, Result: EndMethod main}

{Or}TRATAMIENTO PARA class ir.ast.BoolLiteral y class ir.ast.BoolLiteral PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.VarLocation y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.VarLocation y class ir.ast.UnaryOpExpr PENDIENTE


.globl	pruebaLogica
.type	pruebaLogica, @function 
pruebaLogica: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $true, BoolLiteralLabel1(%rbp)

    mov true(%rbp), %eax
    mov -4(%rbp), %eax

    movl $false, BoolLiteralLabel3(%rbp)


    movl $true, BoolLiteralLabel8(%rbp)

    cmp $0, true(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -32(%rbp) 


    cmp $0, false(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -48(%rbp) 


    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $true, BoolLiteralLabel17(%rbp)

    call pruebaLogica
    movl %eax, RESULTLabel19(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel21(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/program.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -4
OFFSET = -24

parseo exitoso
tamaño lista de codigo tercetos: 22
lista: 
{LABEL, null, null, Result: BeginMethod inc}

{METHODDECL, Metodo{ name=inc, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=x, value=null, size=0}]}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel2}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel4, type=int, expr=0 + 1, size=0}}
{RETURN, null, null, Result: 0 + 1}
{LABEL, null, null, Result: EndMethod inc}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{EXTERNINVK, ExternInvkExpr{id="get_int", type=int, parameters=[]}, null, Result: EXTERNINVKLabel5}
{METHODCALL, inc, 1, Result: RESULTLabel7}
{PARAM, null, null, Result: ExternInvkExpr{id="get_int", type=int, parameters=[]}}
{ASSIGN(=), MethodCallExpr{name=inc, args=[ExternInvkExpr{id="get_int", type=int, parameters=[]}]}, null, Result: VarLocation{name=y, type=int, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel10}
{CEQ(==), 0, 1, Result: VarLocation{name=CEQLabel12, type=boolean, expr=0 == 1, size=0}}
{CMP, VarLocation{name=CEQLabel12, type=boolean, expr=0 == 1, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel13}
{EXTERNINVK, ExternInvkExpr{id="printf", type=void, parameters=[StringLiteral{value="y==1\n"}]}, null, Result: EXTERNINVKLabel15}
{JMP, null, null, Result: endIfLabel14}
{LABEL, null, null, Result: elseCondLabel13}
{EXTERNINVK, ExternInvkExpr{id="printf", type=void, parameters=[StringLiteral{value="y==%d\n"}, 0]}, null, Result: EXTERNINVKLabel17}
{LABEL, null, null, Result: endIfLabel14}
{LABEL, null, null, Result: EndMethod main}



.globl	inc
.type	inc, @function 
inc: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel2(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-12%(ebp) 

    mov 0 + 1(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    call "get_int"
    movl %eax, EXTERNINVKLabel5(%rbp) 

    call inc
    movl %eax, RESULTLabel7(%rbp) 

PARAM

    mov MethodCallExpr{name=inc, args=[ExternInvkExpr{id="get_int", type=int, parameters=[]}]}(%rbp), %eax
    mov -4(%rbp), %eax

    movl $1, IntLiteralLabel10(%rbp)

    movl	$0, %eax
    cmpl	$1, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -24(%rbp)

    mov true(%rbp), %eax
    cmp -24(%rbp), %eax

    jne elseCondLabel13

    call "printf"
    movl %eax, EXTERNINVKLabel15(%rbp) 

    jmp endIfLabel14

.elseCondLabel13

    call "printf"
    movl %eax, EXTERNINVKLabel17(%rbp) 

.endIfLabel14

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_arreglos2.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -16
OFFSET = -28
OFFSET = -40
OFFSET = -48
OFFSET = -60
OFFSET = -76
OFFSET = -88
OFFSET = -4
OFFSET = -16
OFFSET = -28
OFFSET = -36
OFFSET = -44
OFFSET = -52
OFFSET = -60
OFFSET = -72
OFFSET = -84
OFFSET = -92
OFFSET = -112
OFFSET = -120
OFFSET = -128
OFFSET = -140

parseo exitoso
tamaño lista de codigo tercetos: 56
lista: 
{LABEL, null, null, Result: BeginMethod pruArreglos}

{METHODDECL, Metodo{ name=pruArreglos, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{null, 8.87, null, Result: FloatLiteralLabel1}
{ASSIGN(=), 8.87, null, Result: VarLocation{name=y, type=float, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel3}
{null, 4, null, Result: IntLiteralLabel5}
{ASSIGN(=), 4, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{null, 55, null, Result: IntLiteralLabel7}
{null, 2.6, null, Result: FloatLiteralLabel9}
{PLUS(+), 2.6, 0.0, Result: VarLocation{name=PLUSLabel12, type=float, expr=2.6 + 0.0, size=0}}
{ASSIGN(=), 2.6 + 0.0, null, Result: VarLocation{name=B, type=float[], expr=null, size=56}}
{null, 0, null, Result: IntLiteralLabel13}
{LE(<), 0, 0, Result: VarLocation{name=LELabel17, type=boolean, expr=0 < 0, size=0}}
{ASSIGN(=), VarLocation{name=factorLabel18, type=boolean, expr=VarLocation{name=LELabel17, type=boolean, expr=0 < 0, size=0}, size=0}, null, Result: VarLocation{name=C, type=boolean[], expr=null, size=10}}
{null, 1, null, Result: IntLiteralLabel20}
{GEQ(>=), 0, 0, Result: VarLocation{name=GEQLabel24, type=boolean, expr=0 >= 0, size=0}}
{ASSIGN(=), VarLocation{name=GEQLabel24, type=boolean, expr=0 >= 0, size=0}, null, Result: VarLocation{name=C, type=boolean[], expr=null, size=10}}
{null, 0, null, Result: IntLiteralLabel26}
{ARRAYACCESS, A, VarLocation{name=factorLabel27, type=int, expr=0, size=0}, Result: ArrayAccessLabel28}
{RETURN, null, null, Result: ArrayLiteral{id=A, size=5}}
{LABEL, null, null, Result: EndMethod pruArreglos}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, true, null, Result: BoolLiteralLabel30}
{ASSIGN(=), true, null, Result: VarLocation{name=y, type=boolean, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel32}
{null, 58, null, Result: IntLiteralLabel34}
{null, 6, null, Result: IntLiteralLabel36}
{UNARYMINUS(-expr), 6, null, Result: VarLocation{name=UNARYMINUSLabel38, type=int, expr=-6, size=0}}
{MINUS(-), 58, VarLocation{name=UNARYMINUSLabel38, type=int, expr=-6, size=0}, Result: VarLocation{name=MINUSLabel40, type=int, expr=58 - VarLocation{name=UNARYMINUSLabel38, type=int, expr=-6, size=0}, size=0}}
{ASSIGN(=), 58 - VarLocation{name=UNARYMINUSLabel38, type=int, expr=-6, size=0}, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{null, 0, null, Result: IntLiteralLabel41}
{null, 2.6, null, Result: FloatLiteralLabel43}
{UNARYMINUS(-expr), 2.6, null, Result: VarLocation{name=UNARYMINUSLabel45, type=float, expr=-2.6, size=0}}
{ASSIGN(=), -2.6, null, Result: VarLocation{name=B, type=float[], expr=null, size=56}}
{null, 2, null, Result: IntLiteralLabel46}
{null, 4, null, Result: IntLiteralLabel48}
{null, 6, null, Result: IntLiteralLabel50}
{LE(<), 4, 6, Result: VarLocation{name=LELabel52, type=boolean, expr=4 < 6, size=0}}
{NON(!), VarLocation{name=factorLabel53, type=boolean, expr=VarLocation{name=LELabel52, type=boolean, expr=4 < 6, size=0}, size=0}, null, Result: VarLocation{name=NONLabel55, type=boolean, expr=!VarLocation{name=factorLabel53, type=boolean, expr=VarLocation{name=LELabel52, type=boolean, expr=4 < 6, size=0}, size=0}, size=0}}
{ASSIGN(=), !VarLocation{name=factorLabel53, type=boolean, expr=VarLocation{name=LELabel52, type=boolean, expr=4 < 6, size=0}, size=0}, null, Result: VarLocation{name=C, type=boolean[], expr=null, size=10}}
{null, 3, null, Result: IntLiteralLabel56}
{null, 5, null, Result: IntLiteralLabel58}
{null, 7, null, Result: IntLiteralLabel60}
{null, 3, null, Result: IntLiteralLabel62}
{null, 3, null, Result: IntLiteralLabel64}
{PLUS(+), 3, 3, Result: VarLocation{name=PLUSLabel66, type=int, expr=3 + 3, size=0}}
{MINUS(-), 7, VarLocation{name=PLUSLabel66, type=int, expr=3 + 3, size=0}, Result: VarLocation{name=MINUSLabel68, type=int, expr=7 - VarLocation{name=PLUSLabel66, type=int, expr=3 + 3, size=0}, size=0}}
{ARRAYACCESS, A, VarLocation{name=MINUSLabel68, type=int, expr=7 - VarLocation{name=PLUSLabel66, type=int, expr=3 + 3, size=0}, size=0}, Result: ArrayAccessLabel69}
{GEQ(>=), 5, ArrayLiteral{id=A, size=5}, Result: VarLocation{name=GEQLabel71, type=boolean, expr=5 >= ArrayLiteral{id=A, size=5}, size=0}}
{null, true, null, Result: BoolLiteralLabel73}
{OR(||), VarLocation{name=GEQLabel71, type=boolean, expr=5 >= ArrayLiteral{id=A, size=5}, size=0}, true, Result: VarLocation{name=DISYUNCIONLabel75, type=boolean, expr=VarLocation{name=GEQLabel71, type=boolean, expr=5 >= ArrayLiteral{id=A, size=5}, size=0} || true, size=0}}
{ASSIGN(=), VarLocation{name=GEQLabel71, type=boolean, expr=5 >= ArrayLiteral{id=A, size=5}, size=0} || true, null, Result: VarLocation{name=C, type=boolean[], expr=null, size=10}}
{null, 1, null, Result: IntLiteralLabel76}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{logic} FALTA CASO (2do param)class ir.ast.ArrayLiteral
{Or}TRATAMIENTO PARA class ir.ast.VarLocation y class ir.ast.BoolLiteral PENDIENTE


.globl	pruArreglos
.type	pruArreglos, @function 
pruArreglos: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $8.87, FloatLiteralLabel1(%rbp)

    mov 8.87(%rbp), %eax
    mov -4(%rbp), %eax

    movl $0, IntLiteralLabel3(%rbp)

    movl $4, IntLiteralLabel5(%rbp)

    mov 4(%rbp), %eax
    mov -16(%rbp), %eax

    movl $55, IntLiteralLabel7(%rbp)

    movl $2.6, FloatLiteralLabel9(%rbp)


    mov 2.6 + 0.0(%rbp), %eax
    mov -28(%rbp), %eax

    movl $0, IntLiteralLabel13(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -60(%rbp)

    mov -64(%rbp), %eax
    mov -48(%rbp), %eax

    movl $1, IntLiteralLabel20(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setge %al
    movzbl %al, %eax
    movl	%eax, -88(%rbp)

    mov -88(%rbp), %eax
    mov -76(%rbp), %eax

    movl $0, IntLiteralLabel26(%rbp)

ARRAYACCESS

    mov ArrayLiteral{id=A, size=5}(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $true, BoolLiteralLabel30(%rbp)

    mov true(%rbp), %eax
    mov -4(%rbp), %eax

    movl $1, IntLiteralLabel32(%rbp)

    movl $58, IntLiteralLabel34(%rbp)

    movl $6, IntLiteralLabel36(%rbp)

    movl	$6, %eax 
	   negl	%eax 
    movl	%eax, -28(%rbp) 


    mov 58 - VarLocation{name=UNARYMINUSLabel38, type=int, expr=-6, size=0}(%rbp), %eax
    mov -16(%rbp), %eax

    movl $0, IntLiteralLabel41(%rbp)

    movl $2.6, FloatLiteralLabel43(%rbp)


    mov -2.6(%rbp), %eax
    mov -44(%rbp), %eax

    movl $2, IntLiteralLabel46(%rbp)

    movl $4, IntLiteralLabel48(%rbp)

    movl $6, IntLiteralLabel50(%rbp)

    movl	$4, %eax
    cmpl	$6, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -72(%rbp)

    cmp $0, -76(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -84(%rbp) 

    mov !VarLocation{name=factorLabel53, type=boolean, expr=VarLocation{name=LELabel52, type=boolean, expr=4 < 6, size=0}, size=0}(%rbp), %eax
    mov -60(%rbp), %eax

    movl $3, IntLiteralLabel56(%rbp)

    movl $5, IntLiteralLabel58(%rbp)

    movl $7, IntLiteralLabel60(%rbp)

    movl $3, IntLiteralLabel62(%rbp)

    movl $3, IntLiteralLabel64(%rbp)

    mov $3, %eax 
    mov $3, %edx 
    add %eax, %edx 
    mov %edx,-112%(ebp) 


ARRAYACCESS

    movl	$5, %eax
    setge %al
    movzbl %al, %eax
    movl	%eax, -128(%rbp)

    movl $true, BoolLiteralLabel73(%rbp)


    mov VarLocation{name=GEQLabel71, type=boolean, expr=5 >= ArrayLiteral{id=A, size=5}, size=0} || true(%rbp), %eax
    mov -92(%rbp), %eax

    movl $1, IntLiteralLabel76(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_arreglos.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -20
OFFSET = -32
OFFSET = -44
OFFSET = -56
OFFSET = -60
OFFSET = -72
OFFSET = -84
OFFSET = -88
OFFSET = -96
OFFSET = -112
OFFSET = -124
OFFSET = -136
OFFSET = -140
OFFSET = -148
OFFSET = -164
OFFSET = -172
OFFSET = -184
OFFSET = -192
OFFSET = -204
OFFSET = -208
OFFSET = -216
OFFSET = -236
OFFSET = -248
OFFSET = -252
OFFSET = -260
OFFSET = -272
OFFSET = -280
OFFSET = -296
OFFSET = -300
OFFSET = -312
Error: Method pruArreglos must return int

parseo exitoso
tamaño lista de codigo tercetos: 96
lista: 
{LABEL, null, null, Result: BeginMethod pruArreglos}

{METHODDECL, Metodo{ name=pruArreglos, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{GE(>), 0, 0, Result: VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}}
{CMP, VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel4}
{null, 0, null, Result: IntLiteralLabel6}
{null, 1, null, Result: IntLiteralLabel8}
{MINUS(-), 1, 0, Result: VarLocation{name=MINUSLabel11, type=int, expr=1 - 0, size=0}}
{ASSIGN(=), 1 - 0, null, Result: VarLocation{name=res, type=float[], expr=null, size=8}}
{JMP, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: elseCondLabel4}
{LABEL, null, null, Result: endIfLabel5}
{CEQ(==), 0, 0, Result: VarLocation{name=CEQLabel14, type=boolean, expr=0 == 0, size=0}}
{CMP, VarLocation{name=CEQLabel14, type=boolean, expr=0 == 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel15}
{null, 1, null, Result: IntLiteralLabel17}
{null, 1, null, Result: IntLiteralLabel19}
{MINUS(-), 1, 1, Result: VarLocation{name=MINUSLabel21, type=int, expr=1 - 1, size=0}}
{null, 5, null, Result: IntLiteralLabel23}
{MULTIPLY(*), 0, 5, Result: VarLocation{name=MULTIPLYLabel25, type=int, expr=0 * 5, size=0}}
{ASSIGN(=), 0 * 5, null, Result: VarLocation{name=res, type=float[], expr=null, size=8}}
{JMP, null, null, Result: endIfLabel16}
{LABEL, null, null, Result: elseCondLabel15}
{MINUS(-), 0, 0, Result: VarLocation{name=MINUSLabel28, type=int, expr=0 - 0, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=res, type=float[], expr=null, size=8}}
{LABEL, null, null, Result: endIfLabel16}
{null, 0, null, Result: IntLiteralLabel30}
{ASSIGN(=), 0, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 589, null, Result: IntLiteralLabel33}
{LE(<), 0, 589, Result: VarLocation{name=LELabel35, type=boolean, expr=0 < 589, size=0}}
{LABEL, null, null, Result: BeginWhileLabel37}
{CMP, VarLocation{name=factorLabel36, type=boolean, expr=VarLocation{name=LELabel35, type=boolean, expr=0 < 589, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel38}
{null, 2, null, Result: IntLiteralLabel41}
{MULTIPLY(*), 0, 2, Result: VarLocation{name=MULTIPLYLabel43, type=int, expr=0 * 2, size=0}}
{ASSIGN(=), 0 * 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=589}}
{null, 1, null, Result: IntLiteralLabel44}
{ASSIGN(=), 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel37}
{LABEL, null, null, Result: EndWhileLabel38}
{null, 8, null, Result: IntLiteralLabel46}
{ASSIGN(=), 8, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel49}
{GEQ(>=), 0, 0, Result: VarLocation{name=GEQLabel51, type=boolean, expr=0 >= 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel52}
{CMP, VarLocation{name=GEQLabel51, type=boolean, expr=0 >= 0, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel53}
{null, 2, null, Result: IntLiteralLabel56}
{MULTIPLY(*), 0, 2, Result: VarLocation{name=MULTIPLYLabel58, type=int, expr=0 * 2, size=0}}
{null, 8, null, Result: IntLiteralLabel59}
{PLUS(+), 0 * 2, 8, Result: VarLocation{name=PLUSLabel61, type=int, expr=0 * 2 + 8, size=0}}
{ARRAYACCESS, A, VarLocation{name=PLUSLabel61, type=int, expr=0 * 2 + 8, size=0}, Result: ArrayAccessLabel62}
{null, 3, null, Result: IntLiteralLabel64}
{PLUS(+), ArrayLiteral{id=A, size=589}, 3, Result: VarLocation{name=PLUSLabel66, type=int, expr=ArrayLiteral{id=A, size=589} + 3, size=0}}
{ASSIGN(=), ArrayLiteral{id=A, size=589} + 3, null, Result: VarLocation{name=B, type=float[], expr=null, size=56}}
{null, 1, null, Result: IntLiteralLabel67}
{ASSIGN(=), 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel52}
{LABEL, null, null, Result: EndWhileLabel53}
{null, 0, null, Result: IntLiteralLabel69}
{ASSIGN(=), 0, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 5, null, Result: IntLiteralLabel72}
{null, 9, null, Result: IntLiteralLabel74}
{MULTIPLY(*), 5, 9, Result: VarLocation{name=MULTIPLYLabel76, type=int, expr=5 * 9, size=0}}
{null, 40, null, Result: IntLiteralLabel78}
{MINUS(-), VarLocation{name=MULTIPLYLabel76, type=int, expr=5 * 9, size=0}, 40, Result: VarLocation{name=MINUSLabel80, type=int, expr=VarLocation{name=MULTIPLYLabel76, type=int, expr=5 * 9, size=0} - 40, size=0}}
{LEQ(<=), 0, VarLocation{name=MULTIPLYLabel76, type=int, expr=5 * 9, size=0} - 40, Result: VarLocation{name=LEQLabel81, type=boolean, expr=0 <= VarLocation{name=MULTIPLYLabel76, type=int, expr=5 * 9, size=0} - 40, size=0}}
{LABEL, null, null, Result: BeginWhileLabel82}
{CMP, VarLocation{name=LEQLabel81, type=boolean, expr=0 <= VarLocation{name=MULTIPLYLabel76, type=int, expr=5 * 9, size=0} - 40, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel83}
{null, 2, null, Result: IntLiteralLabel86}
{MULTIPLY(*), 0, 2, Result: VarLocation{name=MULTIPLYLabel88, type=int, expr=0 * 2, size=0}}
{null, 8, null, Result: IntLiteralLabel89}
{PLUS(+), 0 * 2, 8, Result: VarLocation{name=PLUSLabel91, type=int, expr=0 * 2 + 8, size=0}}
{ARRAYACCESS, A, VarLocation{name=PLUSLabel91, type=int, expr=0 * 2 + 8, size=0}, Result: ArrayAccessLabel92}
{ARRAYACCESS, B, VarLocation{name=factorLabel94, type=int, expr=0, size=0}, Result: ArrayAccessLabel95}
{GE(>), ArrayLiteral{id=A, size=589}, ArrayLiteral{id=B, size=56}, Result: VarLocation{name=GELabel97, type=boolean, expr=ArrayLiteral{id=A, size=589} > ArrayLiteral{id=B, size=56}, size=0}}
{ASSIGN(=), ArrayLiteral{id=A, size=589} > ArrayLiteral{id=B, size=56}, null, Result: VarLocation{name=C, type=boolean[], expr=null, size=5}}
{null, 1, null, Result: IntLiteralLabel99}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel101, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel82}
{LABEL, null, null, Result: EndWhileLabel83}
{null, 0, null, Result: IntLiteralLabel102}
{ARRAYACCESS, res, VarLocation{name=factorLabel103, type=int, expr=0, size=0}, Result: ArrayAccessLabel104}
{LABEL, null, null, Result: EndMethod pruArreglos}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel106}
{null, 8, null, Result: IntLiteralLabel108}
{METHODCALL, pruArreglos, 2, Result: RESULTLabel110}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruArreglos, args=[4, 8]}]}, null, Result: EXTERNINVKLabel112}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[]}, null, Result: EXTERNINVKLabel113}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.IntLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.ArrayLiteral y class ir.ast.IntLiteral PENDIENTE
{logic} FALTA CASO (2do param)class ir.ast.BinOpExpr
{Add}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.IntLiteral PENDIENTE
{logic} FALTA CASO (1er param)class ir.ast.ArrayLiteral
{logic} FALTA CASO (2do param)class ir.ast.ArrayLiteral


.globl	pruArreglos
.type	pruArreglos, @function 
pruArreglos: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    mov true(%rbp), %eax
    cmp -12(%rbp), %eax

    jne elseCondLabel4

    movl $0, IntLiteralLabel6(%rbp)

    movl $1, IntLiteralLabel8(%rbp)

    mov $1, %eax
    mov $0, %edx
    sub %eax, %edx
    mov %edx,-32%(ebp)

    mov 1 - 0(%rbp), %eax
    mov -20(%rbp), %eax

    jmp endIfLabel5

.elseCondLabel4

.endIfLabel5

    movl	$0, %eax
    cmpl	$0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -44(%rbp)

    mov true(%rbp), %eax
    cmp -44(%rbp), %eax

    jne elseCondLabel15

    movl $1, IntLiteralLabel17(%rbp)

    movl $1, IntLiteralLabel19(%rbp)

    mov $1, %eax
    mov $1, %edx
    sub %eax, %edx
    mov %edx,-56%(ebp)

    movl $5, IntLiteralLabel23(%rbp)

    mov $0, %eax
    mov $5, %edx
    imul %edx, %eax
    mov %eax,-72%(ebp)

    mov 0 * 5(%rbp), %eax
    mov -60(%rbp), %eax

    jmp endIfLabel16

.elseCondLabel15

    mov $0, %eax
    mov $0, %edx
    sub %eax, %edx
    mov %edx,-84%(ebp)

    mov 0(%rbp), %eax
    mov -88(%rbp), %eax

.endIfLabel16

    movl $0, IntLiteralLabel30(%rbp)

    mov 0(%rbp), %eax
    mov -96(%rbp), %eax

    movl $589, IntLiteralLabel33(%rbp)

    movl	$0, %eax
    cmpl	$589, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -112(%rbp)

.BeginWhileLabel37

    mov true(%rbp), %eax
    cmp -116(%rbp), %eax

    jne EndWhileLabel38

    movl $2, IntLiteralLabel41(%rbp)

    mov $0, %eax
    mov $2, %edx
    imul %edx, %eax
    mov %eax,-136%(ebp)

    mov 0 * 2(%rbp), %eax
    mov -124(%rbp), %eax

    movl $1, IntLiteralLabel44(%rbp)

    mov 1(%rbp), %eax
    mov -140(%rbp), %eax

    jmp BeginWhileLabel37

.EndWhileLabel38

    movl $8, IntLiteralLabel46(%rbp)

    mov 8(%rbp), %eax
    mov -148(%rbp), %eax

    movl $0, IntLiteralLabel49(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setge %al
    movzbl %al, %eax
    movl	%eax, -164(%rbp)

.BeginWhileLabel52

    mov true(%rbp), %eax
    cmp -164(%rbp), %eax

    jne EndWhileLabel53

    movl $2, IntLiteralLabel56(%rbp)

    mov $0, %eax
    mov $2, %edx
    imul %edx, %eax
    mov %eax,-184%(ebp)

    movl $8, IntLiteralLabel59(%rbp)


ARRAYACCESS

    movl $3, IntLiteralLabel64(%rbp)


    mov ArrayLiteral{id=A, size=589} + 3(%rbp), %eax
    mov -172(%rbp), %eax

    movl $1, IntLiteralLabel67(%rbp)

    mov 1(%rbp), %eax
    mov -208(%rbp), %eax

    jmp BeginWhileLabel52

.EndWhileLabel53

    movl $0, IntLiteralLabel69(%rbp)

    mov 0(%rbp), %eax
    mov -216(%rbp), %eax

    movl $5, IntLiteralLabel72(%rbp)

    movl $9, IntLiteralLabel74(%rbp)

    mov $5, %eax
    mov $9, %edx
    imul %edx, %eax
    mov %eax,-236%(ebp)

    movl $40, IntLiteralLabel78(%rbp)

    mov -236(%ebp) , %eax 
    mov $40, %edx
    sub %edx, %eax 
    mov %edx,-248%(ebp) 

    movl	$0, %eax
    setle %al
    movzbl %al, %eax
    movl	%eax, -252(%rbp)

.BeginWhileLabel82

    mov true(%rbp), %eax
    cmp -252(%rbp), %eax

    jne EndWhileLabel83

    movl $2, IntLiteralLabel86(%rbp)

    mov $0, %eax
    mov $2, %edx
    imul %edx, %eax
    mov %eax,-272%(ebp)

    movl $8, IntLiteralLabel89(%rbp)


ARRAYACCESS

ARRAYACCESS

    setg	%al
    movzbl %al, %eax
    movl	%eax, -296(%rbp)

    mov ArrayLiteral{id=A, size=589} > ArrayLiteral{id=B, size=56}(%rbp), %eax
    mov -260(%rbp), %eax

    movl $1, IntLiteralLabel99(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-312%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -300(%rbp), %eax

    jmp BeginWhileLabel82

.EndWhileLabel83

    movl $0, IntLiteralLabel102(%rbp)

ARRAYACCESS

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel106(%rbp)

    movl $8, IntLiteralLabel108(%rbp)

    call pruArreglos
    movl %eax, RESULTLabel110(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel112(%rbp) 

    call "printf"
    movl %eax, EXTERNINVKLabel113(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_Asignaciones.ctds ... -------------------
parseo iniciado

parseo exitoso
tamaño lista de codigo tercetos: 10
lista: 
{LABEL, null, null, Result: BeginMethod pruAritmetica}

{METHODDECL, Metodo{ name=pruAritmetica, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{LABEL, null, null, Result: EndMethod pruAritmetica}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 3, null, Result: IntLiteralLabel1}
{METHODCALL, pruAritmetica, 1, Result: RESULTLabel3}
{PARAM, null, null, Result: 3}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[3]}]}, null, Result: EXTERNINVKLabel5}
{LABEL, null, null, Result: EndMethod main}



.globl	pruAritmetica
.type	pruAritmetica, @function 
pruAritmetica: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $3, IntLiteralLabel1(%rbp)

    call pruAritmetica
    movl %eax, RESULTLabel3(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel5(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/testAssing.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -32
OFFSET = -36
OFFSET = -48
OFFSET = -52
OFFSET = -64
OFFSET = -72
OFFSET = -84
OFFSET = -88
OFFSET = -96

parseo exitoso
tamaño lista de codigo tercetos: 30
lista: 
{LABEL, null, null, Result: BeginMethod aritmTest}

{METHODDECL, Metodo{ name=aritmTest, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel1}
{ASSIGN(=), 1, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel3}
{ASSIGN(=), 2, null, Result: VarLocation{name=b, type=int, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel5}
{PLUS(+), 1, 0, Result: VarLocation{name=PLUSLabel8, type=int, expr=1 + 0, size=0}}
{ASSIGN(=), 1 + 0, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel10}
{PLUS(+), 0, 2, Result: VarLocation{name=PLUSLabel12, type=int, expr=0 + 2, size=0}}
{ASSIGN(=), 0 + 2, null, Result: VarLocation{name=b, type=int, expr=null, size=0}}
{DIVIDE(/), 0, 0, Result: VarLocation{name=DIVIDELabel15, type=int, expr=0 / 0, size=0}}
{ASSIGN(=), VarLocation{name=DIVIDELabel15, type=int, expr=0 / 0, size=0}, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 3, null, Result: IntLiteralLabel18}
{MOD(%), 0, 3, Result: VarLocation{name=MODLabel20, type=int, expr=0 % 3, size=0}}
{ASSIGN(=), 0 % 3, null, Result: VarLocation{name=c, type=int, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel21}
{ASSIGN(=), 1, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel23}
{ASSIGN(=), 2, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod aritmTest}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 5, null, Result: IntLiteralLabel26}
{METHODCALL, aritmTest, 1, Result: RESULTLabel28}
{PARAM, null, null, Result: 5}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=aritmTest, args=[5]}]}, null, Result: EXTERNINVKLabel30}
{LABEL, null, null, Result: EndMethod main}



.globl	aritmTest
.type	aritmTest, @function 
aritmTest: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel1(%rbp)

    mov 1(%rbp), %eax
    mov -4(%rbp), %eax

    movl $2, IntLiteralLabel3(%rbp)

    mov 2(%rbp), %eax
    mov -12(%rbp), %eax

    movl $1, IntLiteralLabel5(%rbp)

    mov $1, %eax 
    mov $0, %edx 
    add %eax, %edx 
    mov %edx,-32%(ebp) 

    mov 1 + 0(%rbp), %eax
    mov -20(%rbp), %eax

    movl $2, IntLiteralLabel10(%rbp)

    mov $0, %eax 
    mov $2, %edx 
    add %eax, %edx 
    mov %edx,-48%(ebp) 

    mov 0 + 2(%rbp), %eax
    mov -36(%rbp), %eax

DIVIDE(/)

    mov -64(%rbp), %eax
    mov -52(%rbp), %eax

    movl $3, IntLiteralLabel18(%rbp)

    movl	$3, %eax 
    idivl $0, %eax 
    movl	%edx, -84(%rbp)

    mov 0 % 3(%rbp), %eax
    mov -72(%rbp), %eax

    movl $1, IntLiteralLabel21(%rbp)

    mov 1(%rbp), %eax
    mov -88(%rbp), %eax

    movl $2, IntLiteralLabel23(%rbp)

    mov 2(%rbp), %eax
    mov -96(%rbp), %eax

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $5, IntLiteralLabel26(%rbp)

    call aritmTest
    movl %eax, RESULTLabel28(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel30(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_bloques02.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20
OFFSET = -28
OFFSET = -40
OFFSET = -44
OFFSET = -60

parseo exitoso
tamaño lista de codigo tercetos: 36
lista: 
{LABEL, null, null, Result: BeginMethod breaks}

{METHODDECL, Metodo{ name=breaks, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=g, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel1}
{ASSIGN(=), 0, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 10, null, Result: IntLiteralLabel4}
{LE(<), 0, 10, Result: VarLocation{name=LELabel6, type=boolean, expr=0 < 10, size=0}}
{LABEL, null, null, Result: BeginWhileLabel8}
{CMP, VarLocation{name=factorLabel7, type=boolean, expr=VarLocation{name=LELabel6, type=boolean, expr=0 < 10, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel9}
{null, 1, null, Result: IntLiteralLabel11}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel13, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 2.3, null, Result: FloatLiteralLabel14}
{ASSIGN(=), 2.3, null, Result: VarLocation{name=j, type=float, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel17}
{LE(<), 0, 0, Result: VarLocation{name=LELabel19, type=boolean, expr=0 < 0, size=0}}
{CMP, VarLocation{name=LELabel19, type=boolean, expr=0 < 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel20}
{JMP, null, null, Result: EndWhileLabel9}
{JMP, null, null, Result: endIfLabel21}
{LABEL, null, null, Result: elseCondLabel20}
{JMP, null, null, Result: BeginWhileLabel8}
{LABEL, null, null, Result: endIfLabel21}
{JMP, null, null, Result: BeginWhileLabel8}
{LABEL, null, null, Result: EndWhileLabel9}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod breaks}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel23}
{METHODCALL, breaks, 1, Result: RESULTLabel25}
{PARAM, null, null, Result: 1}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[StringLiteral{value="%f resultado : "}, MethodCallExpr{name=breaks, args=[1]}]}, null, Result: EXTERNINVKLabel27}
{null, 1, null, Result: IntLiteralLabel28}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}



.globl	breaks
.type	breaks, @function 
breaks: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel1(%rbp)

    mov 0(%rbp), %eax
    mov -4(%rbp), %eax

    movl $10, IntLiteralLabel4(%rbp)

    movl	$0, %eax
    cmpl	$10, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -20(%rbp)

.BeginWhileLabel8

    mov true(%rbp), %eax
    cmp -24(%rbp), %eax

    jne EndWhileLabel9

    movl $1, IntLiteralLabel11(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-40%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -28(%rbp), %eax

    movl $2.3, FloatLiteralLabel14(%rbp)

    mov 2.3(%rbp), %eax
    mov -44(%rbp), %eax

    movl $0, IntLiteralLabel17(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -60(%rbp)

    mov true(%rbp), %eax
    cmp -60(%rbp), %eax

    jne elseCondLabel20

    jmp EndWhileLabel9

    jmp endIfLabel21

.elseCondLabel20

    jmp BeginWhileLabel8

.endIfLabel21

    jmp BeginWhileLabel8

.EndWhileLabel9

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel23(%rbp)

    call breaks
    movl %eax, RESULTLabel25(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel27(%rbp) 

    movl $1, IntLiteralLabel28(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_bloques.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20
OFFSET = -28
OFFSET = -40
OFFSET = -52

parseo exitoso
tamaño lista de codigo tercetos: 34
lista: 
{LABEL, null, null, Result: BeginMethod breaks}

{METHODDECL, Metodo{ name=breaks, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=g, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel1}
{ASSIGN(=), 0, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 10, null, Result: IntLiteralLabel4}
{LE(<), 0, 10, Result: VarLocation{name=LELabel6, type=boolean, expr=0 < 10, size=0}}
{LABEL, null, null, Result: BeginWhileLabel8}
{CMP, VarLocation{name=factorLabel7, type=boolean, expr=VarLocation{name=LELabel6, type=boolean, expr=0 < 10, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel9}
{null, 1, null, Result: IntLiteralLabel11}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel13, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel15}
{LE(<), 0, 0, Result: VarLocation{name=LELabel17, type=boolean, expr=0 < 0, size=0}}
{CMP, VarLocation{name=LELabel17, type=boolean, expr=0 < 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel18}
{JMP, null, null, Result: EndWhileLabel9}
{JMP, null, null, Result: endIfLabel19}
{LABEL, null, null, Result: elseCondLabel18}
{JMP, null, null, Result: BeginWhileLabel8}
{LABEL, null, null, Result: endIfLabel19}
{JMP, null, null, Result: BeginWhileLabel8}
{LABEL, null, null, Result: EndWhileLabel9}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod breaks}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel21}
{METHODCALL, breaks, 1, Result: RESULTLabel23}
{PARAM, null, null, Result: 1}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[StringLiteral{value="%f resultado : "}, MethodCallExpr{name=breaks, args=[1]}]}, null, Result: EXTERNINVKLabel25}
{null, 1, null, Result: IntLiteralLabel26}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}



.globl	breaks
.type	breaks, @function 
breaks: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel1(%rbp)

    mov 0(%rbp), %eax
    mov -4(%rbp), %eax

    movl $10, IntLiteralLabel4(%rbp)

    movl	$0, %eax
    cmpl	$10, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -20(%rbp)

.BeginWhileLabel8

    mov true(%rbp), %eax
    cmp -24(%rbp), %eax

    jne EndWhileLabel9

    movl $1, IntLiteralLabel11(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-40%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -28(%rbp), %eax

    movl $0, IntLiteralLabel15(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -52(%rbp)

    mov true(%rbp), %eax
    cmp -52(%rbp), %eax

    jne elseCondLabel18

    jmp EndWhileLabel9

    jmp endIfLabel19

.elseCondLabel18

    jmp BeginWhileLabel8

.endIfLabel19

    jmp BeginWhileLabel8

.EndWhileLabel9

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel21(%rbp)

    call breaks
    movl %eax, RESULTLabel23(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel25(%rbp) 

    movl $1, IntLiteralLabel26(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_booleanos.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -12
OFFSET = -12
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -32

parseo exitoso
tamaño lista de codigo tercetos: 35
lista: 
{LABEL, null, null, Result: BeginMethod neg}

{METHODDECL, Metodo{ name=neg, return_not_void=true, typeReturn=boolean, parameters [Simbolo{type=boolean, name=b, value=null, size=0}]}, null, Result: null}
{NON(!), false, null, Result: VarLocation{name=NONLabel2, type=boolean, expr=!false, size=0}}
{RETURN, null, null, Result: !false}
{LABEL, null, null, Result: EndMethod neg}
{LABEL, null, null, Result: BeginMethod and}

{METHODDECL, Metodo{ name=and, return_not_void=true, typeReturn=boolean, parameters [Simbolo{type=boolean, name=a, value=null, size=0}, Simbolo{type=boolean, name=b, value=null, size=0}]}, null, Result: null}
{AND(&&), false, false, Result: VarLocation{name=CONJUNCIONLabel5, type=boolean, expr=false && false, size=0}}
{RETURN, null, null, Result: false && false}
{LABEL, null, null, Result: EndMethod and}
{LABEL, null, null, Result: BeginMethod or}

{METHODDECL, Metodo{ name=or, return_not_void=true, typeReturn=boolean, parameters [Simbolo{type=boolean, name=a, value=null, size=0}, Simbolo{type=boolean, name=b, value=null, size=0}]}, null, Result: null}
{OR(||), false, false, Result: VarLocation{name=DISYUNCIONLabel8, type=boolean, expr=false || false, size=0}}
{RETURN, null, null, Result: false || false}
{LABEL, null, null, Result: EndMethod or}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{null, true, null, Result: BoolLiteralLabel9}
{ASSIGN(=), true, null, Result: VarLocation{name=a, type=boolean, expr=null, size=0}}
{null, false, null, Result: BoolLiteralLabel11}
{ASSIGN(=), false, null, Result: VarLocation{name=b, type=boolean, expr=null, size=0}}
{METHODCALL, neg, 1, Result: RESULTLabel14}
{PARAM, null, null, Result: false}
{ASSIGN(=), MethodCallExpr{name=neg, args=[false]}, null, Result: VarLocation{name=b, type=boolean, expr=null, size=0}}
{METHODCALL, and, 2, Result: RESULTLabel18}
{PARAM, null, null, Result: false}
{PARAM, null, null, Result: false}
{METHODCALL, neg, 1, Result: RESULTLabel21}
{PARAM, null, null, Result: false}
{METHODCALL, or, 2, Result: RESULTLabel23}
{PARAM, null, null, Result: MethodCallExpr{name=and, args=[false, false]}}
{PARAM, null, null, Result: MethodCallExpr{name=neg, args=[false]}}
{ASSIGN(=), MethodCallExpr{name=or, args=[MethodCallExpr{name=and, args=[false, false]}, MethodCallExpr{name=neg, args=[false]}]}, null, Result: VarLocation{name=c, type=boolean, expr=null, size=0}}
{EXTERNINVK, ExternInvkExpr{id="printf", type=boolean, parameters=[false]}, null, Result: EXTERNINVKLabel26}
{LABEL, null, null, Result: EndMethod main}

{And}TRATAMIENTO PARA class ir.ast.BoolLiteral y class ir.ast.BoolLiteral PENDIENTE
{Or}TRATAMIENTO PARA class ir.ast.BoolLiteral y class ir.ast.BoolLiteral PENDIENTE


.globl	neg
.type	neg, @function 
neg: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    cmp $0, false(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -8(%rbp) 

    mov !false(%rbp), %eax

    leave
    ret



.globl	and
.type	and, @function 
and: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp


    mov false && false(%rbp), %eax

    leave
    ret



.globl	or
.type	or, @function 
or: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp


    mov false || false(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $true, BoolLiteralLabel9(%rbp)

    mov true(%rbp), %eax
    mov -4(%rbp), %eax

    movl $false, BoolLiteralLabel11(%rbp)

    mov false(%rbp), %eax
    mov -12(%rbp), %eax

    call neg
    movl %eax, RESULTLabel14(%rbp) 

PARAM

    mov MethodCallExpr{name=neg, args=[false]}(%rbp), %eax
    mov -20(%rbp), %eax

    call and
    movl %eax, RESULTLabel18(%rbp) 

PARAM

PARAM

    call neg
    movl %eax, RESULTLabel21(%rbp) 

PARAM

    call or
    movl %eax, RESULTLabel23(%rbp) 

PARAM

PARAM

    mov MethodCallExpr{name=or, args=[MethodCallExpr{name=and, args=[false, false]}, MethodCallExpr{name=neg, args=[false]}]}(%rbp), %eax
    mov -32(%rbp), %eax

    call "printf"
    movl %eax, EXTERNINVKLabel26(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_break.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20
OFFSET = -28
OFFSET = -40
OFFSET = -52

parseo exitoso
tamaño lista de codigo tercetos: 34
lista: 
{LABEL, null, null, Result: BeginMethod breaks}

{METHODDECL, Metodo{ name=breaks, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=g, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel1}
{ASSIGN(=), 0, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 10, null, Result: IntLiteralLabel4}
{LE(<), 0, 10, Result: VarLocation{name=LELabel6, type=boolean, expr=0 < 10, size=0}}
{LABEL, null, null, Result: BeginWhileLabel8}
{CMP, VarLocation{name=factorLabel7, type=boolean, expr=VarLocation{name=LELabel6, type=boolean, expr=0 < 10, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel9}
{null, 1, null, Result: IntLiteralLabel11}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel13, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel15}
{LE(<), 0, 0, Result: VarLocation{name=LELabel17, type=boolean, expr=0 < 0, size=0}}
{CMP, VarLocation{name=LELabel17, type=boolean, expr=0 < 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel18}
{JMP, null, null, Result: EndWhileLabel9}
{JMP, null, null, Result: endIfLabel19}
{LABEL, null, null, Result: elseCondLabel18}
{JMP, null, null, Result: BeginWhileLabel8}
{LABEL, null, null, Result: endIfLabel19}
{JMP, null, null, Result: BeginWhileLabel8}
{LABEL, null, null, Result: EndWhileLabel9}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod breaks}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel21}
{METHODCALL, breaks, 1, Result: RESULTLabel23}
{PARAM, null, null, Result: 1}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[StringLiteral{value="%f resultado : "}, MethodCallExpr{name=breaks, args=[1]}]}, null, Result: EXTERNINVKLabel25}
{null, 1, null, Result: IntLiteralLabel26}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}



.globl	breaks
.type	breaks, @function 
breaks: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel1(%rbp)

    mov 0(%rbp), %eax
    mov -4(%rbp), %eax

    movl $10, IntLiteralLabel4(%rbp)

    movl	$0, %eax
    cmpl	$10, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -20(%rbp)

.BeginWhileLabel8

    mov true(%rbp), %eax
    cmp -24(%rbp), %eax

    jne EndWhileLabel9

    movl $1, IntLiteralLabel11(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-40%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -28(%rbp), %eax

    movl $0, IntLiteralLabel15(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -52(%rbp)

    mov true(%rbp), %eax
    cmp -52(%rbp), %eax

    jne elseCondLabel18

    jmp EndWhileLabel9

    jmp endIfLabel19

.elseCondLabel18

    jmp BeginWhileLabel8

.endIfLabel19

    jmp BeginWhileLabel8

.EndWhileLabel9

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel21(%rbp)

    call breaks
    movl %eax, RESULTLabel23(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel25(%rbp) 

    movl $1, IntLiteralLabel26(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_comentarios2.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -16
OFFSET = -24
Error: Method pruAritmetica must return int

parseo exitoso
tamaño lista de codigo tercetos: 20
lista: 
{LABEL, null, null, Result: BeginMethod pruAritmetica}

{METHODDECL, Metodo{ name=pruAritmetica, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{GE(>), 0, 0, Result: VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}}
{CMP, VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel4}
{ASSIGN(=), 0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: elseCondLabel4}
{ASSIGN(=), 0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: EndMethod pruAritmetica}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel9}
{null, 8, null, Result: IntLiteralLabel11}
{METHODCALL, pruAritmetica, 2, Result: RESULTLabel13}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[4, 8]}]}, null, Result: EXTERNINVKLabel15}
{LABEL, null, null, Result: EndMethod main}



.globl	pruAritmetica
.type	pruAritmetica, @function 
pruAritmetica: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    mov true(%rbp), %eax
    cmp -12(%rbp), %eax

    jne elseCondLabel4

    mov 0(%rbp), %eax
    mov -16(%rbp), %eax

    jmp endIfLabel5

.elseCondLabel4

    mov 0(%rbp), %eax
    mov -24(%rbp), %eax

.endIfLabel5

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel9(%rbp)

    movl $8, IntLiteralLabel11(%rbp)

    call pruAritmetica
    movl %eax, RESULTLabel13(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel15(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_comentarios.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -16
OFFSET = -28
OFFSET = -32
Error: Method pruAritmetica must return int

parseo exitoso
tamaño lista de codigo tercetos: 22
lista: 
{LABEL, null, null, Result: BeginMethod pruAritmetica}

{METHODDECL, Metodo{ name=pruAritmetica, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{GE(>), 0, 0, Result: VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}}
{CMP, VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel4}
{null, 5, null, Result: IntLiteralLabel7}
{PLUS(+), 0, 5, Result: VarLocation{name=PLUSLabel9, type=int, expr=0 + 5, size=0}}
{ASSIGN(=), 0 + 5, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: elseCondLabel4}
{ASSIGN(=), 0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: EndMethod pruAritmetica}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel12}
{null, 8, null, Result: IntLiteralLabel14}
{METHODCALL, pruAritmetica, 2, Result: RESULTLabel16}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[4, 8]}]}, null, Result: EXTERNINVKLabel18}
{LABEL, null, null, Result: EndMethod main}



.globl	pruAritmetica
.type	pruAritmetica, @function 
pruAritmetica: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    mov true(%rbp), %eax
    cmp -12(%rbp), %eax

    jne elseCondLabel4

    movl $5, IntLiteralLabel7(%rbp)

    mov $0, %eax 
    mov $5, %edx 
    add %eax, %edx 
    mov %edx,-28%(ebp) 

    mov 0 + 5(%rbp), %eax
    mov -16(%rbp), %eax

    jmp endIfLabel5

.elseCondLabel4

    mov 0(%rbp), %eax
    mov -32(%rbp), %eax

.endIfLabel5

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel12(%rbp)

    movl $8, IntLiteralLabel14(%rbp)

    call pruAritmetica
    movl %eax, RESULTLabel16(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel18(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_condiciones.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -20
OFFSET = -32
OFFSET = -40
OFFSET = -44
OFFSET = -56
OFFSET = -64
OFFSET = -68
OFFSET = -84
OFFSET = -100
OFFSET = -108
OFFSET = -112
OFFSET = -124
OFFSET = -132
OFFSET = -136
OFFSET = -152
OFFSET = -160
OFFSET = -172
OFFSET = -180
OFFSET = -192
OFFSET = -200
OFFSET = -204
OFFSET = -212
OFFSET = -224
OFFSET = -232
OFFSET = -244
OFFSET = -252
OFFSET = -256
OFFSET = -268
OFFSET = -276
OFFSET = -284
OFFSET = -300
OFFSET = -316
OFFSET = -324
OFFSET = -336
OFFSET = -344
OFFSET = -348
OFFSET = -364
OFFSET = -380
OFFSET = -388
OFFSET = -392
OFFSET = -404
OFFSET = -412
OFFSET = -420
OFFSET = -432
OFFSET = -440
OFFSET = -452
OFFSET = -460
OFFSET = -472
OFFSET = -480
OFFSET = -488
OFFSET = -504
OFFSET = -520
OFFSET = -528
OFFSET = -540
OFFSET = -548

parseo exitoso
tamaño lista de codigo tercetos: 122
lista: 
{LABEL, null, null, Result: BeginMethod dados}

{METHODDECL, Metodo{ name=dados, return_not_void=true, typeReturn=float, parameters [Simbolo{type=int, name=d1, value=null, size=0}, Simbolo{type=int, name=d2, value=null, size=0}, Simbolo{type=int, name=d3, value=null, size=0}]}, null, Result: null}
{null, 6, null, Result: IntLiteralLabel2}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel4, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel4, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel6, type=boolean, expr=!VarLocation{name=CEQLabel4, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel8}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel10, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel10, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel12, type=boolean, expr=!VarLocation{name=CEQLabel10, type=boolean, expr=0 == 6, size=0}, size=0}}
{AND(&&), !VarLocation{name=CEQLabel4, type=boolean, expr=0 == 6, size=0}, !VarLocation{name=CEQLabel10, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel13, type=boolean, expr=!VarLocation{name=CEQLabel4, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel10, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel15}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel17, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel17, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel19, type=boolean, expr=!VarLocation{name=CEQLabel17, type=boolean, expr=0 == 6, size=0}, size=0}}
{AND(&&), !VarLocation{name=CEQLabel4, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel10, type=boolean, expr=0 == 6, size=0}, !VarLocation{name=CEQLabel17, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel20, type=boolean, expr=!VarLocation{name=CEQLabel4, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel10, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel17, type=boolean, expr=0 == 6, size=0}, size=0}}
{CMP, VarLocation{name=CONJUNCIONLabel20, type=boolean, expr=!VarLocation{name=CEQLabel4, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel10, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel17, type=boolean, expr=0 == 6, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel21}
{null, 1.00, null, Result: FloatLiteralLabel23}
{RETURN, null, null, Result: 1.00}
{JMP, null, null, Result: endIfLabel22}
{LABEL, null, null, Result: elseCondLabel21}
{LABEL, null, null, Result: endIfLabel22}
{null, 6, null, Result: IntLiteralLabel26}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0}}
{null, 6, null, Result: IntLiteralLabel31}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel35, type=boolean, expr=!VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0}, size=0}}
{AND(&&), VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0}, !VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel36, type=boolean, expr=VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel38}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel42, type=boolean, expr=!VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}, size=0}}
{AND(&&), VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0}, !VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel43, type=boolean, expr=VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel46}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel50, type=boolean, expr=!VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel52}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0}}
{AND(&&), !VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0}, VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel56, type=boolean, expr=!VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel58}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel62, type=boolean, expr=!VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}, size=0}}
{AND(&&), !VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0}, !VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel63, type=boolean, expr=!VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}, size=0}}
{OR(||), VarLocation{name=CONJUNCIONLabel43, type=boolean, expr=VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}, size=0}, VarLocation{name=CONJUNCIONLabel63, type=boolean, expr=!VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}, size=0}, Result: VarLocation{name=DISYUNCIONLabel65, type=boolean, expr=VarLocation{name=CONJUNCIONLabel43, type=boolean, expr=VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel63, type=boolean, expr=!VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel67}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel71, type=boolean, expr=!VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel73}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel77, type=boolean, expr=!VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0}, size=0}}
{AND(&&), !VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0}, !VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel78, type=boolean, expr=!VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel80}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel82, type=boolean, expr=0 == 6, size=0}}
{AND(&&), !VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0}, VarLocation{name=CEQLabel82, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel84, type=boolean, expr=!VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel82, type=boolean, expr=0 == 6, size=0}, size=0}}
{OR(||), VarLocation{name=CONJUNCIONLabel43, type=boolean, expr=VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel63, type=boolean, expr=!VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}, size=0}, VarLocation{name=CONJUNCIONLabel84, type=boolean, expr=!VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel82, type=boolean, expr=0 == 6, size=0}, size=0}, Result: VarLocation{name=DISYUNCIONLabel86, type=boolean, expr=VarLocation{name=CONJUNCIONLabel43, type=boolean, expr=VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel63, type=boolean, expr=!VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel84, type=boolean, expr=!VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel82, type=boolean, expr=0 == 6, size=0}, size=0}, size=0}}
{CMP, VarLocation{name=DISYUNCIONLabel86, type=boolean, expr=VarLocation{name=CONJUNCIONLabel43, type=boolean, expr=VarLocation{name=CEQLabel28, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel33, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel40, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel63, type=boolean, expr=!VarLocation{name=CEQLabel48, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel54, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel60, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel84, type=boolean, expr=!VarLocation{name=CEQLabel69, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel75, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel82, type=boolean, expr=0 == 6, size=0}, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel87}
{null, 4.00, null, Result: FloatLiteralLabel89}
{RETURN, null, null, Result: 4.00}
{JMP, null, null, Result: endIfLabel88}
{LABEL, null, null, Result: elseCondLabel87}
{LABEL, null, null, Result: endIfLabel88}
{null, 6, null, Result: IntLiteralLabel92}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0}}
{null, 6, null, Result: IntLiteralLabel97}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0}}
{AND(&&), VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0}, VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel101, type=boolean, expr=VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel103}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel107, type=boolean, expr=!VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}, size=0}}
{AND(&&), VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0}, !VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel108, type=boolean, expr=VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel111}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0}}
{null, 6, null, Result: IntLiteralLabel116}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel120, type=boolean, expr=!VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0}, size=0}}
{AND(&&), VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0}, !VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel121, type=boolean, expr=VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel123}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel125, type=boolean, expr=0 == 6, size=0}}
{AND(&&), VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0}, VarLocation{name=CEQLabel125, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel127, type=boolean, expr=VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel125, type=boolean, expr=0 == 6, size=0}, size=0}}
{OR(||), VarLocation{name=CONJUNCIONLabel108, type=boolean, expr=VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}, size=0}, VarLocation{name=CONJUNCIONLabel127, type=boolean, expr=VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel125, type=boolean, expr=0 == 6, size=0}, size=0}, Result: VarLocation{name=DISYUNCIONLabel129, type=boolean, expr=VarLocation{name=CONJUNCIONLabel108, type=boolean, expr=VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel127, type=boolean, expr=VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel125, type=boolean, expr=0 == 6, size=0}, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel131}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0}}
{NON(!), VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0}, null, Result: VarLocation{name=NONLabel135, type=boolean, expr=!VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel137}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel139, type=boolean, expr=0 == 6, size=0}}
{AND(&&), !VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0}, VarLocation{name=CEQLabel139, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel141, type=boolean, expr=!VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel139, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel143}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel145, type=boolean, expr=0 == 6, size=0}}
{AND(&&), !VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel139, type=boolean, expr=0 == 6, size=0}, VarLocation{name=CEQLabel145, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel147, type=boolean, expr=!VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel139, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel145, type=boolean, expr=0 == 6, size=0}, size=0}}
{OR(||), VarLocation{name=CONJUNCIONLabel108, type=boolean, expr=VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel127, type=boolean, expr=VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel125, type=boolean, expr=0 == 6, size=0}, size=0}, VarLocation{name=CONJUNCIONLabel147, type=boolean, expr=!VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel139, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel145, type=boolean, expr=0 == 6, size=0}, size=0}, Result: VarLocation{name=DISYUNCIONLabel149, type=boolean, expr=VarLocation{name=CONJUNCIONLabel108, type=boolean, expr=VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel127, type=boolean, expr=VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel125, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel147, type=boolean, expr=!VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel139, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel145, type=boolean, expr=0 == 6, size=0}, size=0}, size=0}}
{CMP, VarLocation{name=DISYUNCIONLabel149, type=boolean, expr=VarLocation{name=CONJUNCIONLabel108, type=boolean, expr=VarLocation{name=CEQLabel94, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel99, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel105, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel127, type=boolean, expr=VarLocation{name=CEQLabel113, type=boolean, expr=0 == 6, size=0} && !VarLocation{name=CEQLabel118, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel125, type=boolean, expr=0 == 6, size=0}, size=0} || VarLocation{name=CONJUNCIONLabel147, type=boolean, expr=!VarLocation{name=CEQLabel133, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel139, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel145, type=boolean, expr=0 == 6, size=0}, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel150}
{null, 8.50, null, Result: FloatLiteralLabel152}
{RETURN, null, null, Result: 8.50}
{JMP, null, null, Result: endIfLabel151}
{LABEL, null, null, Result: elseCondLabel150}
{LABEL, null, null, Result: endIfLabel151}
{null, 6, null, Result: IntLiteralLabel155}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel157, type=boolean, expr=0 == 6, size=0}}
{null, 6, null, Result: IntLiteralLabel160}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel162, type=boolean, expr=0 == 6, size=0}}
{AND(&&), VarLocation{name=CEQLabel157, type=boolean, expr=0 == 6, size=0}, VarLocation{name=CEQLabel162, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel164, type=boolean, expr=VarLocation{name=CEQLabel157, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel162, type=boolean, expr=0 == 6, size=0}, size=0}}
{null, 6, null, Result: IntLiteralLabel166}
{CEQ(==), 0, 6, Result: VarLocation{name=CEQLabel168, type=boolean, expr=0 == 6, size=0}}
{AND(&&), VarLocation{name=CEQLabel157, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel162, type=boolean, expr=0 == 6, size=0}, VarLocation{name=CEQLabel168, type=boolean, expr=0 == 6, size=0}, Result: VarLocation{name=CONJUNCIONLabel170, type=boolean, expr=VarLocation{name=CEQLabel157, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel162, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel168, type=boolean, expr=0 == 6, size=0}, size=0}}
{CMP, VarLocation{name=CONJUNCIONLabel170, type=boolean, expr=VarLocation{name=CEQLabel157, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel162, type=boolean, expr=0 == 6, size=0} && VarLocation{name=CEQLabel168, type=boolean, expr=0 == 6, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel171}
{null, 10.00, null, Result: FloatLiteralLabel173}
{RETURN, null, null, Result: 10.00}
{JMP, null, null, Result: endIfLabel172}
{LABEL, null, null, Result: elseCondLabel171}
{LABEL, null, null, Result: endIfLabel172}
{LABEL, null, null, Result: EndMethod dados}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel175}
{null, 6, null, Result: IntLiteralLabel177}
{null, 9, null, Result: IntLiteralLabel179}
{METHODCALL, dados, 3, Result: RESULTLabel181}
{PARAM, null, null, Result: 1}
{PARAM, null, null, Result: 6}
{PARAM, null, null, Result: 9}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[MethodCallExpr{name=dados, args=[1, 6, 9]}]}, null, Result: EXTERNINVKLabel183}
{LABEL, null, null, Result: EndMethod main}

{And}TRATAMIENTO PARA class ir.ast.UnaryOpExpr y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.VarLocation y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.UnaryOpExpr y class ir.ast.VarLocation PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.UnaryOpExpr y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.VarLocation PENDIENTE
{Or}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.VarLocation PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.VarLocation y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.VarLocation PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.UnaryOpExpr y class ir.ast.VarLocation PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.VarLocation PENDIENTE
{Or}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.VarLocation PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.VarLocation PENDIENTE


.globl	dados
.type	dados, @function 
dados: 
    enter   $(12), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $6, IntLiteralLabel2(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    cmp $0, -12(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -20(%rbp) 

    movl $6, IntLiteralLabel8(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -32(%rbp)

    cmp $0, -32(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -40(%rbp) 


    movl $6, IntLiteralLabel15(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -56(%rbp)

    cmp $0, -56(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -64(%rbp) 


    mov true(%rbp), %eax
    cmp -68(%rbp), %eax

    jne elseCondLabel21

    movl $1.00, FloatLiteralLabel23(%rbp)

    mov 1.00(%rbp), %eax

    jmp endIfLabel22

.elseCondLabel21

.endIfLabel22

    movl $6, IntLiteralLabel26(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -84(%rbp)

    movl $6, IntLiteralLabel31(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -100(%rbp)

    cmp $0, -100(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -108(%rbp) 


    movl $6, IntLiteralLabel38(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -124(%rbp)

    cmp $0, -124(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -132(%rbp) 


    movl $6, IntLiteralLabel46(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -152(%rbp)

    cmp $0, -152(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -160(%rbp) 

    movl $6, IntLiteralLabel52(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -172(%rbp)


    movl $6, IntLiteralLabel58(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -192(%rbp)

    cmp $0, -192(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -200(%rbp) 


    cmp	$0, -136(%rbp)
    jne .L0
    cmp	$0, -204(%rbp)
    je .L0
    mov	$1, %eax
    jmp .L1
.L0:
    movl	$0, %eax
    jmp .L2
.L1:
    movl	%eax, -212(%rbp)
.L2:

    movl $6, IntLiteralLabel67(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -224(%rbp)

    cmp $0, -224(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -232(%rbp) 

    movl $6, IntLiteralLabel73(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -244(%rbp)

    cmp $0, -244(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -252(%rbp) 


    movl $6, IntLiteralLabel80(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -268(%rbp)



    mov true(%rbp), %eax
    cmp -284(%rbp), %eax

    jne elseCondLabel87

    movl $4.00, FloatLiteralLabel89(%rbp)

    mov 4.00(%rbp), %eax

    jmp endIfLabel88

.elseCondLabel87

.endIfLabel88

    movl $6, IntLiteralLabel92(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -300(%rbp)

    movl $6, IntLiteralLabel97(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -316(%rbp)

    cmp	$0, -300(%rbp)
    je .L3
    cmp	$0, -316(%rbp)
    je .L3
    mov	$1, %eax
    jmp .L4
.L3:
    movl	$0, %eax
    jmp .L5
.L4:
    movl	%eax, -324(%rbp)
.L5:

    movl $6, IntLiteralLabel103(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -336(%rbp)

    cmp $0, -336(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -344(%rbp) 


    movl $6, IntLiteralLabel111(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -364(%rbp)

    movl $6, IntLiteralLabel116(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -380(%rbp)

    cmp $0, -380(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -388(%rbp) 


    movl $6, IntLiteralLabel123(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -404(%rbp)


    cmp	$0, -348(%rbp)
    jne .L6
    cmp	$0, -412(%rbp)
    je .L6
    mov	$1, %eax
    jmp .L7
.L6:
    movl	$0, %eax
    jmp .L8
.L7:
    movl	%eax, -420(%rbp)
.L8:

    movl $6, IntLiteralLabel131(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -432(%rbp)

    cmp $0, -432(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -440(%rbp) 

    movl $6, IntLiteralLabel137(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -452(%rbp)


    movl $6, IntLiteralLabel143(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -472(%rbp)



    mov true(%rbp), %eax
    cmp -488(%rbp), %eax

    jne elseCondLabel150

    movl $8.50, FloatLiteralLabel152(%rbp)

    mov 8.50(%rbp), %eax

    jmp endIfLabel151

.elseCondLabel150

.endIfLabel151

    movl $6, IntLiteralLabel155(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -504(%rbp)

    movl $6, IntLiteralLabel160(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -520(%rbp)

    cmp	$0, -504(%rbp)
    je .L9
    cmp	$0, -520(%rbp)
    je .L9
    mov	$1, %eax
    jmp .L10
.L9:
    movl	$0, %eax
    jmp .L11
.L10:
    movl	%eax, -528(%rbp)
.L11:

    movl $6, IntLiteralLabel166(%rbp)

    movl	$0, %eax
    cmpl	$6, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -540(%rbp)


    mov true(%rbp), %eax
    cmp -548(%rbp), %eax

    jne elseCondLabel171

    movl $10.00, FloatLiteralLabel173(%rbp)

    mov 10.00(%rbp), %eax

    jmp endIfLabel172

.elseCondLabel171

.endIfLabel172

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel175(%rbp)

    movl $6, IntLiteralLabel177(%rbp)

    movl $9, IntLiteralLabel179(%rbp)

    call dados
    movl %eax, RESULTLabel181(%rbp) 

PARAM

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel183(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_continuebreak.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -16
OFFSET = -24
OFFSET = -40
OFFSET = -48
OFFSET = -60
OFFSET = -72
OFFSET = -84
OFFSET = -88
OFFSET = -100
OFFSET = -108
OFFSET = -112
OFFSET = -120
OFFSET = -128
OFFSET = -136
OFFSET = -144
Error: Method pruContinue must return float

parseo exitoso
tamaño lista de codigo tercetos: 55
lista: 
{LABEL, null, null, Result: BeginMethod pruContinue}

{METHODDECL, Metodo{ name=pruContinue, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=x, value=null, size=0}, Simbolo{type=int, name=b, value=null, size=0}]}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel1}
{UNARYMINUS(-expr), 1, null, Result: VarLocation{name=UNARYMINUSLabel3, type=int, expr=-1, size=0}}
{ASSIGN(=), -1, null, Result: VarLocation{name=total, type=float, expr=null, size=0}}
{null, 23, null, Result: IntLiteralLabel4}
{ASSIGN(=), 23, null, Result: VarLocation{name=n, type=int, expr=null, size=0}}
{null, 23, null, Result: IntLiteralLabel6}
{ASSIGN(=), 23, null, Result: VarLocation{name=i, type=float, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel9}
{GEQ(>=), 0.0, 0, Result: VarLocation{name=GEQLabel11, type=boolean, expr=0.0 >= 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel13}
{CMP, VarLocation{name=factorLabel12, type=boolean, expr=VarLocation{name=GEQLabel11, type=boolean, expr=0.0 >= 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel14}
{null, 1, null, Result: IntLiteralLabel16}
{MINUS(-), 0.0, 1, Result: VarLocation{name=MINUSLabel18, type=float, expr=0.0 - 1, size=0}}
{ASSIGN(=), 0.0 - 1, null, Result: VarLocation{name=i, type=float, expr=null, size=0}}
{LE(<), 0.0, 0, Result: VarLocation{name=LELabel21, type=boolean, expr=0.0 < 0, size=0}}
{CMP, VarLocation{name=LELabel21, type=boolean, expr=0.0 < 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel22}
{null, 0, null, Result: IntLiteralLabel25}
{NEQ(!=), 0.0, 0, Result: VarLocation{name=NEQLabel27, type=boolean, expr=0.0 != 0, size=0}}
{CMP, VarLocation{name=NEQLabel27, type=boolean, expr=0.0 != 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel28}
{MULTIPLY(*), 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel32, type=int, expr=0.0 * 0.0, size=0}}
{MULTIPLY(*), 0.0 * 0.0, 0, Result: VarLocation{name=MULTIPLYLabel34, type=int, expr=0.0 * 0.0 * 0, size=0}}
{ASSIGN(=), 0.0 * 0.0 * 0, null, Result: VarLocation{name=total, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel29}
{LABEL, null, null, Result: elseCondLabel28}
{LABEL, null, null, Result: endIfLabel29}
{JMP, null, null, Result: BeginWhileLabel13}
{JMP, null, null, Result: endIfLabel23}
{LABEL, null, null, Result: elseCondLabel22}
{null, 1000.2343, null, Result: FloatLiteralLabel35}
{UNARYMINUS(-expr), 1000.2343, null, Result: VarLocation{name=UNARYMINUSLabel37, type=float, expr=-1000.2343, size=0}}
{null, 6752, null, Result: IntLiteralLabel38}
{PLUS(+), -1000.2343, 6752, Result: VarLocation{name=PLUSLabel40, type=float, expr=-1000.2343 + 6752, size=0}}
{ASSIGN(=), -1000.2343 + 6752, null, Result: VarLocation{name=total, type=float, expr=null, size=0}}
{JMP, null, null, Result: EndWhileLabel14}
{LABEL, null, null, Result: endIfLabel23}
{JMP, null, null, Result: BeginWhileLabel13}
{LABEL, null, null, Result: EndWhileLabel14}
{null, 2, null, Result: IntLiteralLabel41}
{UNARYMINUS(-expr), 2, null, Result: VarLocation{name=UNARYMINUSLabel43, type=int, expr=-2, size=0}}
{MULTIPLY(*), -2, 0.0, Result: VarLocation{name=MULTIPLYLabel45, type=int, expr=-2 * 0.0, size=0}}
{LABEL, null, null, Result: EndMethod pruContinue}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 3.0, null, Result: FloatLiteralLabel46}
{null, 2, null, Result: IntLiteralLabel48}
{METHODCALL, pruContinue, 2, Result: RESULTLabel50}
{PARAM, null, null, Result: 3.0}
{PARAM, null, null, Result: 2}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[MethodCallExpr{name=pruContinue, args=[3.0, 2]}]}, null, Result: EXTERNINVKLabel52}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.IntLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.IntLiteral PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Add}TRATAMIENTO PARA class ir.ast.UnaryOpExpr y class ir.ast.IntLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.UnaryOpExpr y class ir.ast.FloatLiteral PENDIENTE


.globl	pruContinue
.type	pruContinue, @function 
pruContinue: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel1(%rbp)

    movl	$1, %eax 
	   negl	%eax 
    movl	%eax, -12(%rbp) 

    mov -1(%rbp), %eax
    mov -4(%rbp), %eax

    movl $23, IntLiteralLabel4(%rbp)

    mov 23(%rbp), %eax
    mov -16(%rbp), %eax

    movl $23, IntLiteralLabel6(%rbp)

    mov 23(%rbp), %eax
    mov -24(%rbp), %eax

    movl $0, IntLiteralLabel9(%rbp)

    movl	$0.0, %eax
    cmpl	$0, %eax
    setge %al
    movzbl %al, %eax
    movl	%eax, -40(%rbp)

.BeginWhileLabel13

    mov true(%rbp), %eax
    cmp -44(%rbp), %eax

    jne EndWhileLabel14

    movl $1, IntLiteralLabel16(%rbp)


    mov 0.0 - 1(%rbp), %eax
    mov -48(%rbp), %eax

    movl	$0.0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -72(%rbp)

    mov true(%rbp), %eax
    cmp -72(%rbp), %eax

    jne elseCondLabel22

    movl $0, IntLiteralLabel25(%rbp)

    movl	$0.0, %eax
    cmpl	$0, %eax
    setgne %al
    movzbl %al, %eax
    movl	%eax, -84(%rbp)

    mov true(%rbp), %eax
    cmp -84(%rbp), %eax

    jne elseCondLabel28



    mov 0.0 * 0.0 * 0(%rbp), %eax
    mov -88(%rbp), %eax

    jmp endIfLabel29

.elseCondLabel28

.endIfLabel29

    jmp BeginWhileLabel13

    jmp endIfLabel23

.elseCondLabel22

    movl $1000.2343, FloatLiteralLabel35(%rbp)


    movl $6752, IntLiteralLabel38(%rbp)


    mov -1000.2343 + 6752(%rbp), %eax
    mov -112(%rbp), %eax

    jmp EndWhileLabel14

.endIfLabel23

    jmp BeginWhileLabel13

.EndWhileLabel14

    movl $2, IntLiteralLabel41(%rbp)

    movl	$2, %eax 
	   negl	%eax 
    movl	%eax, -136(%rbp) 


    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $3.0, FloatLiteralLabel46(%rbp)

    movl $2, IntLiteralLabel48(%rbp)

    call pruContinue
    movl %eax, RESULTLabel50(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel52(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_expresiones01.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20
OFFSET = -24
OFFSET = -40
OFFSET = -52
OFFSET = -68
OFFSET = -76
OFFSET = -88
OFFSET = -92
OFFSET = -104
OFFSET = -108
OFFSET = -120
OFFSET = -124
OFFSET = -136

parseo exitoso
tamaño lista de codigo tercetos: 55
lista: 
{LABEL, null, null, Result: BeginMethod prueba}

{METHODDECL, Metodo{ name=prueba, return_not_void=true, typeReturn=float, parameters [Simbolo{type=int, name=b, value=null, size=0}]}, null, Result: null}
{null, 50, null, Result: IntLiteralLabel1}
{ASSIGN(=), 50, null, Result: VarLocation{name=g, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel4}
{GE(>), 0, 0, Result: VarLocation{name=GELabel6, type=boolean, expr=0 > 0, size=0}}
{CMP, VarLocation{name=GELabel6, type=boolean, expr=0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel7}
{null, 4, null, Result: IntLiteralLabel9}
{ASSIGN(=), 4, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 4, null, Result: IntLiteralLabel12}
{CEQ(==), 0, 4, Result: VarLocation{name=CEQLabel14, type=boolean, expr=0 == 4, size=0}}
{CMP, VarLocation{name=CEQLabel14, type=boolean, expr=0 == 4, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel15}
{null, 4, null, Result: IntLiteralLabel18}
{LE(<), 0, 4, Result: VarLocation{name=LELabel20, type=boolean, expr=0 < 4, size=0}}
{LABEL, null, null, Result: BeginWhileLabel22}
{CMP, VarLocation{name=factorLabel21, type=boolean, expr=VarLocation{name=LELabel20, type=boolean, expr=0 < 4, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel23}
{null, 4, null, Result: IntLiteralLabel25}
{GE(>), 0, 4, Result: VarLocation{name=GELabel27, type=boolean, expr=0 > 4, size=0}}
{LABEL, null, null, Result: BeginWhileLabel29}
{CMP, VarLocation{name=factorLabel28, type=boolean, expr=VarLocation{name=GELabel27, type=boolean, expr=0 > 4, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel30}
{null, 1, null, Result: IntLiteralLabel32}
{MINUS(-), 0, 1, Result: VarLocation{name=MINUSLabel34, type=int, expr=0 - 1, size=0}}
{ASSIGN(=), 0 - 1, null, Result: VarLocation{name=g, type=int, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel36}
{MULTIPLY(*), 0, 2, Result: VarLocation{name=MULTIPLYLabel38, type=int, expr=0 * 2, size=0}}
{ASSIGN(=), 0 * 2, null, Result: VarLocation{name=c, type=float, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel29}
{LABEL, null, null, Result: EndWhileLabel30}
{null, 1, null, Result: IntLiteralLabel40}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel42, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel44}
{DIVIDE(/), 0.0, 2, Result: VarLocation{name=DIVIDELabel46, type=float, expr=VarLocation{name=factorLabel43, type=float, expr=0.0, size=0} / VarLocation{name=factorLabel45, type=int, expr=2, size=0}, size=0}}
{ASSIGN(=), VarLocation{name=factorLabel43, type=float, expr=0.0, size=0} / VarLocation{name=factorLabel45, type=int, expr=2, size=0}, null, Result: VarLocation{name=c, type=float, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel22}
{LABEL, null, null, Result: EndWhileLabel23}
{JMP, null, null, Result: endIfLabel16}
{LABEL, null, null, Result: elseCondLabel15}
{LABEL, null, null, Result: endIfLabel16}
{JMP, null, null, Result: endIfLabel8}
{LABEL, null, null, Result: elseCondLabel7}
{LABEL, null, null, Result: endIfLabel8}
{RETURN, null, null, Result: 0.0}
{LABEL, null, null, Result: EndMethod prueba}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 6, null, Result: IntLiteralLabel48}
{METHODCALL, prueba, 1, Result: RESULTLabel50}
{PARAM, null, null, Result: 6}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[MethodCallExpr{name=prueba, args=[6]}]}, null, Result: EXTERNINVKLabel52}
{LABEL, null, null, Result: EndMethod main}



.globl	prueba
.type	prueba, @function 
prueba: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $50, IntLiteralLabel1(%rbp)

    mov 50(%rbp), %eax
    mov -4(%rbp), %eax

    movl $0, IntLiteralLabel4(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -20(%rbp)

    mov true(%rbp), %eax
    cmp -20(%rbp), %eax

    jne elseCondLabel7

    movl $4, IntLiteralLabel9(%rbp)

    mov 4(%rbp), %eax
    mov -24(%rbp), %eax

    movl $4, IntLiteralLabel12(%rbp)

    movl	$0, %eax
    cmpl	$4, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -40(%rbp)

    mov true(%rbp), %eax
    cmp -40(%rbp), %eax

    jne elseCondLabel15

    movl $4, IntLiteralLabel18(%rbp)

    movl	$0, %eax
    cmpl	$4, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -52(%rbp)

.BeginWhileLabel22

    mov true(%rbp), %eax
    cmp -56(%rbp), %eax

    jne EndWhileLabel23

    movl $4, IntLiteralLabel25(%rbp)

    movl	$0, %eax
    cmpl	$4, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -68(%rbp)

.BeginWhileLabel29

    mov true(%rbp), %eax
    cmp -72(%rbp), %eax

    jne EndWhileLabel30

    movl $1, IntLiteralLabel32(%rbp)

    mov $0, %eax
    mov $1, %edx
    sub %eax, %edx
    mov %edx,-88%(ebp)

    mov 0 - 1(%rbp), %eax
    mov -76(%rbp), %eax

    movl $2, IntLiteralLabel36(%rbp)

    mov $0, %eax
    mov $2, %edx
    imul %edx, %eax
    mov %eax,-104%(ebp)

    mov 0 * 2(%rbp), %eax
    mov -92(%rbp), %eax

    jmp BeginWhileLabel29

.EndWhileLabel30

    movl $1, IntLiteralLabel40(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-120%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -108(%rbp), %eax

    movl $2, IntLiteralLabel44(%rbp)

DIVIDE(/)

    mov VarLocation{name=factorLabel43, type=float, expr=0.0, size=0} / VarLocation{name=factorLabel45, type=int, expr=2, size=0}(%rbp), %eax
    mov -124(%rbp), %eax

    jmp BeginWhileLabel22

.EndWhileLabel23

    jmp endIfLabel16

.elseCondLabel15

.endIfLabel16

    jmp endIfLabel8

.elseCondLabel7

.endIfLabel8

    mov 0.0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $6, IntLiteralLabel48(%rbp)

    call prueba
    movl %eax, RESULTLabel50(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel52(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_expresiones02.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -32
OFFSET = -36
OFFSET = -48
OFFSET = -52
OFFSET = -60
OFFSET = -72
OFFSET = -84
OFFSET = -96

parseo exitoso
tamaño lista de codigo tercetos: 35
lista: 
{LABEL, null, null, Result: BeginMethod prueba}

{METHODDECL, Metodo{ name=prueba, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=p, value=null, size=0}]}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel1}
{ASSIGN(=), 4, null, Result: VarLocation{name=b, type=int, expr=null, size=0}}
{null, 5, null, Result: IntLiteralLabel3}
{ASSIGN(=), 5, null, Result: VarLocation{name=c, type=int, expr=null, size=0}}
{MULTIPLY(*), 0, 0, Result: VarLocation{name=MULTIPLYLabel7, type=int, expr=0 * 0, size=0}}
{ASSIGN(=), 0 * 0, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{PLUS(+), 0, 0, Result: VarLocation{name=PLUSLabel10, type=int, expr=0 + 0, size=0}}
{ASSIGN(=), 0 + 0, null, Result: VarLocation{name=p, type=int, expr=null, size=0}}
{null, 3.14, null, Result: FloatLiteralLabel11}
{ASSIGN(=), 3.14, null, Result: VarLocation{name=pi, type=float, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel13}
{MULTIPLY(*), 2, 0.0, Result: VarLocation{name=MULTIPLYLabel16, type=int, expr=2 * 0.0, size=0}}
{ASSIGN(=), 2 * 0.0, null, Result: VarLocation{name=f, type=float, expr=null, size=0}}
{DIVIDE(/), 0, 0.0, Result: VarLocation{name=DIVIDELabel19, type=float, expr=VarLocation{name=factorLabel17, type=int, expr=0, size=0} / VarLocation{name=factorLabel18, type=float, expr=0.0, size=0}, size=0}}
{null, 5, null, Result: IntLiteralLabel21}
{GE(>), VarLocation{name=DIVIDELabel19, type=float, expr=VarLocation{name=factorLabel17, type=int, expr=0, size=0} / VarLocation{name=factorLabel18, type=float, expr=0.0, size=0}, size=0}, 5, Result: VarLocation{name=GELabel23, type=boolean, expr=VarLocation{name=DIVIDELabel19, type=float, expr=VarLocation{name=factorLabel17, type=int, expr=0, size=0} / VarLocation{name=factorLabel18, type=float, expr=0.0, size=0}, size=0} > 5, size=0}}
{CMP, VarLocation{name=GELabel23, type=boolean, expr=VarLocation{name=DIVIDELabel19, type=float, expr=VarLocation{name=factorLabel17, type=int, expr=0, size=0} / VarLocation{name=factorLabel18, type=float, expr=0.0, size=0}, size=0} > 5, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel24}
{null, 1, null, Result: IntLiteralLabel26}
{RETURN, null, null, Result: 1}
{JMP, null, null, Result: endIfLabel25}
{LABEL, null, null, Result: elseCondLabel24}
{null, 0, null, Result: IntLiteralLabel28}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: endIfLabel25}
{LABEL, null, null, Result: EndMethod prueba}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 6, null, Result: IntLiteralLabel30}
{METHODCALL, prueba, 1, Result: RESULTLabel32}
{PARAM, null, null, Result: 6}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[MethodCallExpr{name=prueba, args=[6]}]}, null, Result: EXTERNINVKLabel34}
{LABEL, null, null, Result: EndMethod main}

{Imul}TRATAMIENTO PARA class ir.ast.IntLiteral y class ir.ast.FloatLiteral PENDIENTE


.globl	prueba
.type	prueba, @function 
prueba: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel1(%rbp)

    mov 4(%rbp), %eax
    mov -4(%rbp), %eax

    movl $5, IntLiteralLabel3(%rbp)

    mov 5(%rbp), %eax
    mov -12(%rbp), %eax

    mov $0, %eax
    mov $0, %edx
    imul %edx, %eax
    mov %eax,-32%(ebp)

    mov 0 * 0(%rbp), %eax
    mov -20(%rbp), %eax

    mov $0, %eax 
    mov $0, %edx 
    add %eax, %edx 
    mov %edx,-48%(ebp) 

    mov 0 + 0(%rbp), %eax
    mov -36(%rbp), %eax

    movl $3.14, FloatLiteralLabel11(%rbp)

    mov 3.14(%rbp), %eax
    mov -52(%rbp), %eax

    movl $2, IntLiteralLabel13(%rbp)


    mov 2 * 0.0(%rbp), %eax
    mov -60(%rbp), %eax

DIVIDE(/)

    movl $5, IntLiteralLabel21(%rbp)

    movl	-84(%rbp), %eax
    cmpl	$5, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -96(%rbp)

    mov true(%rbp), %eax
    cmp -96(%rbp), %eax

    jne elseCondLabel24

    movl $1, IntLiteralLabel26(%rbp)

    mov 1(%rbp), %eax

    jmp endIfLabel25

.elseCondLabel24

    movl $0, IntLiteralLabel28(%rbp)

    mov 0(%rbp), %eax

.endIfLabel25

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $6, IntLiteralLabel30(%rbp)

    call prueba
    movl %eax, RESULTLabel32(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel34(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_float01.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -36
OFFSET = -40
OFFSET = -48
OFFSET = -52
OFFSET = -60
OFFSET = -72
OFFSET = -80
OFFSET = -92
OFFSET = -96
OFFSET = -108
OFFSET = -116
OFFSET = -124
OFFSET = -136
OFFSET = -148
OFFSET = -4
OFFSET = -12

parseo exitoso
tamaño lista de codigo tercetos: 56
lista: 
{LABEL, null, null, Result: BeginMethod potencia}

{METHODDECL, Metodo{ name=potencia, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=x, value=null, size=0}, Simbolo{type=int, name=n, value=null, size=0}]}, null, Result: null}
{null, false, null, Result: BoolLiteralLabel1}
{ASSIGN(=), false, null, Result: VarLocation{name=neg, type=boolean, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel3}
{ASSIGN(=), 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 1.0, null, Result: FloatLiteralLabel5}
{ASSIGN(=), 1.0, null, Result: VarLocation{name=prod, type=float, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel8}
{LE(<), 0, 0, Result: VarLocation{name=LELabel10, type=boolean, expr=0 < 0, size=0}}
{CMP, VarLocation{name=LELabel10, type=boolean, expr=0 < 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel11}
{UNARYMINUS(-expr), 0, null, Result: VarLocation{name=UNARYMINUSLabel14, type=int, expr=-0, size=0}}
{ASSIGN(=), -0, null, Result: VarLocation{name=n, type=int, expr=null, size=0}}
{NON(!), false, null, Result: VarLocation{name=NONLabel16, type=boolean, expr=!false, size=0}}
{ASSIGN(=), !false, null, Result: VarLocation{name=neg, type=boolean, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel12}
{LABEL, null, null, Result: elseCondLabel11}
{LABEL, null, null, Result: endIfLabel12}
{LEQ(<=), 0, 0, Result: VarLocation{name=LEQLabel19, type=boolean, expr=0 <= 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel21}
{CMP, VarLocation{name=factorLabel20, type=boolean, expr=VarLocation{name=LEQLabel19, type=boolean, expr=0 <= 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel22}
{MULTIPLY(*), 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel25, type=int, expr=0.0 * 0.0, size=0}}
{ASSIGN(=), 0.0 * 0.0, null, Result: VarLocation{name=prod, type=float, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel27}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel29, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel21}
{LABEL, null, null, Result: EndWhileLabel22}
{NON(!), false, null, Result: VarLocation{name=NONLabel31, type=boolean, expr=!false, size=0}}
{NON(!), VarLocation{name=NONLabel31, type=boolean, expr=!false, size=0}, null, Result: VarLocation{name=NONLabel33, type=boolean, expr=!VarLocation{name=NONLabel31, type=boolean, expr=!false, size=0}, size=0}}
{CMP, VarLocation{name=NONLabel33, type=boolean, expr=!VarLocation{name=NONLabel31, type=boolean, expr=!false, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel34}
{null, 1.0, null, Result: FloatLiteralLabel36}
{DIVIDE(/), 1.0, 0.0, Result: VarLocation{name=DIVIDELabel39, type=float, expr=VarLocation{name=factorLabel37, type=float, expr=1.0, size=0} / VarLocation{name=factorLabel38, type=float, expr=0.0, size=0}, size=0}}
{RETURN, null, null, Result: VarLocation{name=factorLabel37, type=float, expr=1.0, size=0} / VarLocation{name=factorLabel38, type=float, expr=0.0, size=0}}
{JMP, null, null, Result: endIfLabel35}
{LABEL, null, null, Result: elseCondLabel34}
{RETURN, null, null, Result: 0.0}
{LABEL, null, null, Result: endIfLabel35}
{null, 100.1, null, Result: FloatLiteralLabel41}
{UNARYMINUS(-expr), 100.1, null, Result: VarLocation{name=UNARYMINUSLabel43, type=float, expr=-100.1, size=0}}
{RETURN, null, null, Result: -100.1}
{LABEL, null, null, Result: EndMethod potencia}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{null, 8.0, null, Result: FloatLiteralLabel44}
{ASSIGN(=), 8.0, null, Result: VarLocation{name=a, type=float, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel47}
{METHODCALL, potencia, 2, Result: RESULTLabel49}
{PARAM, null, null, Result: 0.0}
{PARAM, null, null, Result: 2}
{ASSIGN(=), MethodCallExpr{name=potencia, args=[0.0, 2]}, null, Result: VarLocation{name=f, type=float, expr=null, size=0}}
{EXTERNINVK, ExternInvkExpr{id="printf", type=void, parameters=[StringLiteral{value="%f"}, 0.0]}, null, Result: EXTERNINVKLabel52}
{LABEL, null, null, Result: EndMethod main}

{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)


.globl	potencia
.type	potencia, @function 
potencia: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $false, BoolLiteralLabel1(%rbp)

    mov false(%rbp), %eax
    mov -4(%rbp), %eax

    movl $1, IntLiteralLabel3(%rbp)

    mov 1(%rbp), %eax
    mov -12(%rbp), %eax

    movl $1.0, FloatLiteralLabel5(%rbp)

    mov 1.0(%rbp), %eax
    mov -20(%rbp), %eax

    movl $0, IntLiteralLabel8(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -36(%rbp)

    mov true(%rbp), %eax
    cmp -36(%rbp), %eax

    jne elseCondLabel11

    movl	$0, %eax 
	   negl	%eax 
    movl	%eax, -48(%rbp) 

    mov -0(%rbp), %eax
    mov -40(%rbp), %eax

    cmp $0, false(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -60(%rbp) 

    mov !false(%rbp), %eax
    mov -52(%rbp), %eax

    jmp endIfLabel12

.elseCondLabel11

.endIfLabel12

    movl	$0, %eax
    cmpl	$0, %eax
    setle %al
    movzbl %al, %eax
    movl	%eax, -72(%rbp)

.BeginWhileLabel21

    mov true(%rbp), %eax
    cmp -76(%rbp), %eax

    jne EndWhileLabel22


    mov 0.0 * 0.0(%rbp), %eax
    mov -80(%rbp), %eax

    movl $1, IntLiteralLabel27(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-108%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -96(%rbp), %eax

    jmp BeginWhileLabel21

.EndWhileLabel22

    cmp $0, false(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -116(%rbp) 

    cmp $0, -116(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -124(%rbp) 

    mov true(%rbp), %eax
    cmp -124(%rbp), %eax

    jne elseCondLabel34

    movl $1.0, FloatLiteralLabel36(%rbp)

DIVIDE(/)

    mov VarLocation{name=factorLabel37, type=float, expr=1.0, size=0} / VarLocation{name=factorLabel38, type=float, expr=0.0, size=0}(%rbp), %eax

    jmp endIfLabel35

.elseCondLabel34

    mov 0.0(%rbp), %eax

.endIfLabel35

    movl $100.1, FloatLiteralLabel41(%rbp)


    mov -100.1(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $8.0, FloatLiteralLabel44(%rbp)

    mov 8.0(%rbp), %eax
    mov -4(%rbp), %eax

    movl $2, IntLiteralLabel47(%rbp)

    call potencia
    movl %eax, RESULTLabel49(%rbp) 

PARAM

PARAM

    mov MethodCallExpr{name=potencia, args=[0.0, 2]}(%rbp), %eax
    mov -12(%rbp), %eax

    call "printf"
    movl %eax, EXTERNINVKLabel52(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_float02.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -28
OFFSET = -40
OFFSET = -44
OFFSET = -60
OFFSET = -64
OFFSET = -76
OFFSET = -80
OFFSET = -88
OFFSET = -4
OFFSET = -12

parseo exitoso
tamaño lista de codigo tercetos: 38
lista: 
{LABEL, null, null, Result: BeginMethod sumatoria}

{METHODDECL, Metodo{ name=sumatoria, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=b, value=null, size=0}]}, null, Result: null}
{null, 0.0, null, Result: FloatLiteralLabel1}
{ASSIGN(=), 0.0, null, Result: VarLocation{name=total, type=float, expr=null, size=0}}
{ASSIGN(=), 0.0, null, Result: VarLocation{name=i, type=float, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel5}
{GE(>), 0.0, 0, Result: VarLocation{name=GELabel7, type=boolean, expr=0.0 > 0, size=0}}
{null, 0, null, Result: IntLiteralLabel9}
{GE(>), 0.0, 0, Result: VarLocation{name=GELabel11, type=boolean, expr=0.0 > 0, size=0}}
{OR(||), 0.0 > 0, 0.0 > 0, Result: VarLocation{name=DISYUNCIONLabel12, type=boolean, expr=0.0 > 0 || 0.0 > 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel14}
{CMP, VarLocation{name=factorLabel13, type=boolean, expr=VarLocation{name=DISYUNCIONLabel12, type=boolean, expr=0.0 > 0 || 0.0 > 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel15}
{null, 0, null, Result: IntLiteralLabel17}
{GE(>), 0.0, 0, Result: VarLocation{name=GELabel19, type=boolean, expr=0.0 > 0, size=0}}
{CMP, VarLocation{name=GELabel19, type=boolean, expr=0.0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel20}
{PLUS(+), 0.0, 0.0, Result: VarLocation{name=PLUSLabel24, type=float, expr=0.0 + 0.0, size=0}}
{ASSIGN(=), 0.0 + 0.0, null, Result: VarLocation{name=total, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel21}
{LABEL, null, null, Result: elseCondLabel20}
{LABEL, null, null, Result: endIfLabel21}
{null, 1.0, null, Result: FloatLiteralLabel25}
{ASSIGN(=), 1.0, null, Result: VarLocation{name=i, type=float, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel14}
{LABEL, null, null, Result: EndWhileLabel15}
{ASSIGN(=), 0.0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{RETURN, null, null, Result: 0.0}
{LABEL, null, null, Result: EndMethod sumatoria}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{null, 8.0, null, Result: FloatLiteralLabel29}
{ASSIGN(=), 8.0, null, Result: VarLocation{name=a, type=float, expr=null, size=0}}
{METHODCALL, sumatoria, 1, Result: RESULTLabel32}
{PARAM, null, null, Result: 0.0}
{ASSIGN(=), MethodCallExpr{name=sumatoria, args=[0.0]}, null, Result: VarLocation{name=f, type=float, expr=null, size=0}}
{EXTERNINVK, ExternInvkExpr{id="printf", type=void, parameters=[StringLiteral{value="%f"}, 0.0]}, null, Result: EXTERNINVKLabel35}
{LABEL, null, null, Result: EndMethod main}

{Or}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.BinOpExpr PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE


.globl	sumatoria
.type	sumatoria, @function 
sumatoria: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0.0, FloatLiteralLabel1(%rbp)

    mov 0.0(%rbp), %eax
    mov -4(%rbp), %eax

    mov 0.0(%rbp), %eax
    mov -12(%rbp), %eax

    movl $0, IntLiteralLabel5(%rbp)

    movl	$0.0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -28(%rbp)

    movl $0, IntLiteralLabel9(%rbp)

    movl	$0.0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -40(%rbp)


.BeginWhileLabel14

    mov true(%rbp), %eax
    cmp -48(%rbp), %eax

    jne EndWhileLabel15

    movl $0, IntLiteralLabel17(%rbp)

    movl	$0.0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -60(%rbp)

    mov true(%rbp), %eax
    cmp -60(%rbp), %eax

    jne elseCondLabel20


    mov 0.0 + 0.0(%rbp), %eax
    mov -64(%rbp), %eax

    jmp endIfLabel21

.elseCondLabel20

.endIfLabel21

    movl $1.0, FloatLiteralLabel25(%rbp)

    mov 1.0(%rbp), %eax
    mov -80(%rbp), %eax

    jmp BeginWhileLabel14

.EndWhileLabel15

    mov 0.0(%rbp), %eax
    mov -88(%rbp), %eax

    mov 0.0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $8.0, FloatLiteralLabel29(%rbp)

    mov 8.0(%rbp), %eax
    mov -4(%rbp), %eax

    call sumatoria
    movl %eax, RESULTLabel32(%rbp) 

PARAM

    mov MethodCallExpr{name=sumatoria, args=[0.0]}(%rbp), %eax
    mov -12(%rbp), %eax

    call "printf"
    movl %eax, EXTERNINVKLabel35(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_float03.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -36
OFFSET = -40
OFFSET = -48
OFFSET = -52
OFFSET = -68
OFFSET = -80
OFFSET = -84
OFFSET = -92
OFFSET = -104
OFFSET = -112
OFFSET = -116
OFFSET = -128
OFFSET = -136
OFFSET = -144
OFFSET = -156
OFFSET = -168
OFFSET = -4
OFFSET = -12
OFFSET = -16
OFFSET = -24
OFFSET = -28
OFFSET = -36
OFFSET = -40
OFFSET = -48
OFFSET = -52
OFFSET = -64
OFFSET = -72
OFFSET = -76
OFFSET = -84
OFFSET = -92
OFFSET = -100
OFFSET = -116
OFFSET = -128
OFFSET = -132
OFFSET = -140
OFFSET = -156
OFFSET = -172
OFFSET = -184
OFFSET = -196
OFFSET = -200
OFFSET = -224
OFFSET = -228
OFFSET = -240
OFFSET = -244
OFFSET = -260
OFFSET = -268
OFFSET = -272
OFFSET = -288
OFFSET = -300
OFFSET = -304
OFFSET = -308
OFFSET = -324
OFFSET = -328
OFFSET = -336
OFFSET = -340
OFFSET = -352
OFFSET = -360
OFFSET = -364
OFFSET = -376
OFFSET = -380
OFFSET = -392
OFFSET = -396
OFFSET = -408
OFFSET = -412
OFFSET = -424
OFFSET = -428
OFFSET = -432
OFFSET = -444
OFFSET = -452
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -24
OFFSET = -32
OFFSET = -40
OFFSET = -44
OFFSET = -72

parseo exitoso
tamaño lista de codigo tercetos: 189
lista: 
{LABEL, null, null, Result: BeginMethod potencia}

{METHODDECL, Metodo{ name=potencia, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=x, value=null, size=0}, Simbolo{type=int, name=n, value=null, size=0}]}, null, Result: null}
{null, false, null, Result: BoolLiteralLabel1}
{ASSIGN(=), false, null, Result: VarLocation{name=neg, type=boolean, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel3}
{ASSIGN(=), 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 1.0, null, Result: FloatLiteralLabel5}
{ASSIGN(=), 1.0, null, Result: VarLocation{name=prod, type=float, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel8}
{LE(<), 0, 0, Result: VarLocation{name=LELabel10, type=boolean, expr=0 < 0, size=0}}
{CMP, VarLocation{name=LELabel10, type=boolean, expr=0 < 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel11}
{UNARYMINUS(-expr), 0, null, Result: VarLocation{name=UNARYMINUSLabel14, type=int, expr=-0, size=0}}
{ASSIGN(=), -0, null, Result: VarLocation{name=n, type=int, expr=null, size=0}}
{null, true, null, Result: BoolLiteralLabel15}
{ASSIGN(=), true, null, Result: VarLocation{name=neg, type=boolean, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel12}
{LABEL, null, null, Result: elseCondLabel11}
{LABEL, null, null, Result: endIfLabel12}
{LE(<), 0, 0, Result: VarLocation{name=LELabel19, type=boolean, expr=0 < 0, size=0}}
{CEQ(==), 0, 0, Result: VarLocation{name=CEQLabel22, type=boolean, expr=0 == 0, size=0}}
{OR(||), 0 < 0, 0 == 0, Result: VarLocation{name=DISYUNCIONLabel23, type=boolean, expr=0 < 0 || 0 == 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel25}
{CMP, VarLocation{name=factorLabel24, type=boolean, expr=VarLocation{name=DISYUNCIONLabel23, type=boolean, expr=0 < 0 || 0 == 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel26}
{MULTIPLY(*), 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel29, type=int, expr=0.0 * 0.0, size=0}}
{null, 2, null, Result: IntLiteralLabel30}
{MULTIPLY(*), 0.0 * 0.0, 2, Result: VarLocation{name=MULTIPLYLabel32, type=int, expr=0.0 * 0.0 * 2, size=0}}
{ASSIGN(=), 0.0 * 0.0 * 2, null, Result: VarLocation{name=prod, type=float, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel34}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel36, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel25}
{LABEL, null, null, Result: EndWhileLabel26}
{NON(!), false, null, Result: VarLocation{name=NONLabel38, type=boolean, expr=!false, size=0}}
{NON(!), VarLocation{name=NONLabel38, type=boolean, expr=!false, size=0}, null, Result: VarLocation{name=NONLabel40, type=boolean, expr=!VarLocation{name=NONLabel38, type=boolean, expr=!false, size=0}, size=0}}
{CMP, VarLocation{name=NONLabel40, type=boolean, expr=!VarLocation{name=NONLabel38, type=boolean, expr=!false, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel41}
{null, 1.0, null, Result: FloatLiteralLabel43}
{DIVIDE(/), 1.0, 0.0, Result: VarLocation{name=DIVIDELabel46, type=float, expr=VarLocation{name=factorLabel44, type=float, expr=1.0, size=0} / VarLocation{name=factorLabel45, type=float, expr=0.0, size=0}, size=0}}
{RETURN, null, null, Result: VarLocation{name=factorLabel44, type=float, expr=1.0, size=0} / VarLocation{name=factorLabel45, type=float, expr=0.0, size=0}}
{JMP, null, null, Result: endIfLabel42}
{LABEL, null, null, Result: elseCondLabel41}
{RETURN, null, null, Result: 0.0}
{LABEL, null, null, Result: endIfLabel42}
{null, 100.1, null, Result: FloatLiteralLabel48}
{UNARYMINUS(-expr), 100.1, null, Result: VarLocation{name=UNARYMINUSLabel50, type=float, expr=-100.1, size=0}}
{RETURN, null, null, Result: -100.1}
{LABEL, null, null, Result: EndMethod potencia}
{LABEL, null, null, Result: BeginMethod multiples}

{METHODDECL, Metodo{ name=multiples, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=x, value=null, size=0}, Simbolo{type=float, name=y, value=null, size=0}]}, null, Result: null}
{null, 2.0, null, Result: FloatLiteralLabel51}
{UNARYMINUS(-expr), 2.0, null, Result: VarLocation{name=UNARYMINUSLabel53, type=float, expr=-2.0, size=0}}
{ASSIGN(=), -2.0, null, Result: VarLocation{name=a, type=float, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel54}
{UNARYMINUS(-expr), 2, null, Result: VarLocation{name=UNARYMINUSLabel56, type=int, expr=-2, size=0}}
{ASSIGN(=), -2, null, Result: VarLocation{name=b, type=int, expr=null, size=0}}
{null, 3.0, null, Result: FloatLiteralLabel57}
{UNARYMINUS(-expr), 3.0, null, Result: VarLocation{name=UNARYMINUSLabel59, type=float, expr=-3.0, size=0}}
{ASSIGN(=), -3.0, null, Result: VarLocation{name=w, type=float, expr=null, size=0}}
{null, 3.0, null, Result: FloatLiteralLabel60}
{UNARYMINUS(-expr), 3.0, null, Result: VarLocation{name=UNARYMINUSLabel62, type=float, expr=-3.0, size=0}}
{ASSIGN(=), -3.0, null, Result: VarLocation{name=z, type=float, expr=null, size=0}}
{MULTIPLY(*), 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel65, type=int, expr=0.0 * 0.0, size=0}}
{MINUS(-), 0.0 * 0.0, 0.0, Result: VarLocation{name=MINUSLabel67, type=float, expr=0.0 * 0.0 - 0.0, size=0}}
{ASSIGN(=), 0.0 * 0.0 - 0.0, null, Result: VarLocation{name=m, type=float, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel68}
{ASSIGN(=), 0, null, Result: VarLocation{name=j, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel70}
{ASSIGN(=), 0, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel72}
{ASSIGN(=), 0, null, Result: VarLocation{name=k, type=int, expr=null, size=0}}
{null, 5, null, Result: IntLiteralLabel74}
{ASSIGN(=), 5, null, Result: VarLocation{name=n, type=int, expr=null, size=0}}
{GE(>), 0.0, 0.0, Result: VarLocation{name=GELabel78, type=boolean, expr=0.0 > 0.0, size=0}}
{CMP, VarLocation{name=GELabel78, type=boolean, expr=0.0 > 0.0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel79}
{LE(<), 0.0, 0.0, Result: VarLocation{name=LELabel83, type=boolean, expr=0.0 < 0.0, size=0}}
{CMP, VarLocation{name=LELabel83, type=boolean, expr=0.0 < 0.0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel84}
{ASSIGN(=), 0.0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel85}
{LABEL, null, null, Result: elseCondLabel84}
{ASSIGN(=), 0.0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel85}
{JMP, null, null, Result: endIfLabel80}
{LABEL, null, null, Result: elseCondLabel79}
{LEQ(<=), 0, 0, Result: VarLocation{name=LEQLabel90, type=boolean, expr=0 <= 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel92}
{CMP, VarLocation{name=factorLabel91, type=boolean, expr=VarLocation{name=LEQLabel90, type=boolean, expr=0 <= 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel93}
{LEQ(<=), 0, 0, Result: VarLocation{name=LEQLabel96, type=boolean, expr=0 <= 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel97}
{CMP, VarLocation{name=LEQLabel96, type=boolean, expr=0 <= 0, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel98}
{LE(<), 0, 0, Result: VarLocation{name=LELabel101, type=boolean, expr=0 < 0, size=0}}
{CEQ(==), 0, 0, Result: VarLocation{name=CEQLabel104, type=boolean, expr=0 == 0, size=0}}
{OR(||), 0 < 0, 0 == 0, Result: VarLocation{name=DISYUNCIONLabel105, type=boolean, expr=0 < 0 || 0 == 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel109}
{CMP, VarLocation{name=factorLabel108, type=boolean, expr=VarLocation{name=factorLabel107, type=boolean, expr=VarLocation{name=factorLabel106, type=boolean, expr=VarLocation{name=DISYUNCIONLabel105, type=boolean, expr=0 < 0 || 0 == 0, size=0}, size=0}, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel110}
{null, 3, null, Result: IntLiteralLabel112}
{CEQ(==), 0, 3, Result: VarLocation{name=CEQLabel114, type=boolean, expr=0 == 3, size=0}}
{CMP, VarLocation{name=CEQLabel114, type=boolean, expr=0 == 3, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel115}
{null, 2.0, null, Result: FloatLiteralLabel118}
{PLUS(+), 0.0, 2.0, Result: VarLocation{name=PLUSLabel120, type=float, expr=0.0 + 2.0, size=0}}
{ASSIGN(=), 0.0 + 2.0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel116}
{LABEL, null, null, Result: elseCondLabel115}
{null, 10.0, null, Result: FloatLiteralLabel122}
{null, 2.0, null, Result: FloatLiteralLabel124}
{DIVIDE(/), 10.0, 2.0, Result: VarLocation{name=DIVIDELabel126, type=float, expr=VarLocation{name=factorLabel123, type=float, expr=10.0, size=0} / VarLocation{name=factorLabel125, type=float, expr=2.0, size=0}, size=0}}
{MINUS(-), 0.0, VarLocation{name=DIVIDELabel126, type=float, expr=VarLocation{name=factorLabel123, type=float, expr=10.0, size=0} / VarLocation{name=factorLabel125, type=float, expr=2.0, size=0}, size=0}, Result: VarLocation{name=MINUSLabel128, type=float, expr=0.0 - VarLocation{name=DIVIDELabel126, type=float, expr=VarLocation{name=factorLabel123, type=float, expr=10.0, size=0} / VarLocation{name=factorLabel125, type=float, expr=2.0, size=0}, size=0}, size=0}}
{ASSIGN(=), 0.0 - VarLocation{name=DIVIDELabel126, type=float, expr=VarLocation{name=factorLabel123, type=float, expr=10.0, size=0} / VarLocation{name=factorLabel125, type=float, expr=2.0, size=0}, size=0}, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel116}
{null, 1, null, Result: IntLiteralLabel129}
{ASSIGN(=), 1, null, Result: VarLocation{name=k, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel109}
{LABEL, null, null, Result: EndWhileLabel110}
{LE(<), 0.0, 0.0, Result: VarLocation{name=LELabel133, type=boolean, expr=0.0 < 0.0, size=0}}
{null, 0.0, null, Result: FloatLiteralLabel134}
{LE(<), 0.0, 0.0, Result: VarLocation{name=LELabel137, type=boolean, expr=0.0 < 0.0, size=0}}
{AND(&&), 0.0 < 0.0, 0.0 < 0.0, Result: VarLocation{name=CONJUNCIONLabel138, type=boolean, expr=0.0 < 0.0 && 0.0 < 0.0, size=0}}
{CMP, VarLocation{name=CONJUNCIONLabel138, type=boolean, expr=0.0 < 0.0 && 0.0 < 0.0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel139}
{null, 35.0, null, Result: FloatLiteralLabel141}
{null, 4.0, null, Result: FloatLiteralLabel143}
{MULTIPLY(*), 4.0, 0.0, Result: VarLocation{name=MULTIPLYLabel146, type=int, expr=4.0 * 0.0, size=0}}
{PLUS(+), 35.0, 4.0 * 0.0, Result: VarLocation{name=PLUSLabel147, type=float, expr=35.0 + 4.0 * 0.0, size=0}}
{null, 498.0, null, Result: FloatLiteralLabel148}
{MINUS(-), 35.0 + 4.0 * 0.0, 498.0, Result: VarLocation{name=MINUSLabel150, type=float, expr=35.0 + 4.0 * 0.0 - 498.0, size=0}}
{ASSIGN(=), 35.0 + 4.0 * 0.0 - 498.0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel140}
{LABEL, null, null, Result: elseCondLabel139}
{null, 3.2, null, Result: FloatLiteralLabel151}
{MINUS(-), 3.2, 0.0, Result: VarLocation{name=MINUSLabel154, type=float, expr=3.2 - 0.0, size=0}}
{null, 12345.356, null, Result: FloatLiteralLabel155}
{MINUS(-), 3.2 - 0.0, 12345.356, Result: VarLocation{name=MINUSLabel157, type=float, expr=3.2 - 0.0 - 12345.356, size=0}}
{ASSIGN(=), 3.2 - 0.0 - 12345.356, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel140}
{null, 1, null, Result: IntLiteralLabel159}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel161, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel97}
{LABEL, null, null, Result: EndWhileLabel98}
{UNARYMINUS(-expr), 0.0, null, Result: VarLocation{name=UNARYMINUSLabel164, type=float, expr=-0.0, size=0}}
{MULTIPLY(*), 0.0, -0.0, Result: VarLocation{name=MULTIPLYLabel165, type=int, expr=0.0 * -0.0, size=0}}
{null, 23.0, null, Result: FloatLiteralLabel166}
{MULTIPLY(*), 23.0, 0.0, Result: VarLocation{name=MULTIPLYLabel169, type=int, expr=23.0 * 0.0, size=0}}
{PLUS(+), 0.0 * -0.0, 23.0 * 0.0, Result: VarLocation{name=PLUSLabel170, type=int, expr=0.0 * -0.0 + 23.0 * 0.0, size=0}}
{null, 2.0, null, Result: FloatLiteralLabel171}
{null, 4.0, null, Result: FloatLiteralLabel173}
{DIVIDE(/), 2.0, 4.0, Result: VarLocation{name=DIVIDELabel175, type=float, expr=VarLocation{name=factorLabel172, type=float, expr=2.0, size=0} / VarLocation{name=factorLabel174, type=float, expr=4.0, size=0}, size=0}}
{PLUS(+), 0.0 * -0.0 + 23.0 * 0.0, VarLocation{name=factorLabel172, type=float, expr=2.0, size=0} / VarLocation{name=factorLabel174, type=float, expr=4.0, size=0}, Result: VarLocation{name=PLUSLabel176, type=float, expr=0.0 * -0.0 + 23.0 * 0.0 + VarLocation{name=factorLabel172, type=float, expr=2.0, size=0} / VarLocation{name=factorLabel174, type=float, expr=4.0, size=0}, size=0}}
{ASSIGN(=), 0.0 * -0.0 + 23.0 * 0.0 + VarLocation{name=factorLabel172, type=float, expr=2.0, size=0} / VarLocation{name=factorLabel174, type=float, expr=4.0, size=0}, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel178}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel180, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=j, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel92}
{LABEL, null, null, Result: EndWhileLabel93}
{LABEL, null, null, Result: endIfLabel80}
{UNARYMINUS(-expr), 0.0, null, Result: VarLocation{name=UNARYMINUSLabel182, type=float, expr=-0.0, size=0}}
{RETURN, null, null, Result: -0.0}
{LABEL, null, null, Result: EndMethod multiples}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{null, 80.0, null, Result: FloatLiteralLabel183}
{ASSIGN(=), 80.0, null, Result: VarLocation{name=a, type=float, expr=null, size=0}}
{null, 15.0, null, Result: FloatLiteralLabel185}
{UNARYMINUS(-expr), 15.0, null, Result: VarLocation{name=UNARYMINUSLabel187, type=float, expr=-15.0, size=0}}
{ASSIGN(=), -15.0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{null, 4.3, null, Result: FloatLiteralLabel188}
{ASSIGN(=), 4.3, null, Result: VarLocation{name=w, type=float, expr=null, size=0}}
{null, 7.6, null, Result: FloatLiteralLabel190}
{UNARYMINUS(-expr), 7.6, null, Result: VarLocation{name=UNARYMINUSLabel192, type=float, expr=-7.6, size=0}}
{ASSIGN(=), -7.6, null, Result: VarLocation{name=m, type=float, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel194}
{METHODCALL, potencia, 2, Result: RESULTLabel196}
{PARAM, null, null, Result: 0.0}
{PARAM, null, null, Result: 2}
{ASSIGN(=), MethodCallExpr{name=potencia, args=[0.0, 2]}, null, Result: VarLocation{name=f, type=float, expr=null, size=0}}
{null, 2.0, null, Result: FloatLiteralLabel200}
{PLUS(+), 0.0, 2.0, Result: VarLocation{name=PLUSLabel202, type=float, expr=0.0 + 2.0, size=0}}
{METHODCALL, multiples, 2, Result: RESULTLabel203}
{PARAM, null, null, Result: 0.0}
{PARAM, null, null, Result: 0.0 + 2.0}
{EXTERNINVK, ExternInvkExpr{id="printf", type=void, parameters=[StringLiteral{value="%f"}, MethodCallExpr{name=multiples, args=[0.0, 0.0 + 2.0]}]}, null, Result: EXTERNINVKLabel205}
{LABEL, null, null, Result: EndMethod main}

{Or}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.BinOpExpr PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.IntLiteral PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.FloatLiteral PENDIENTE
{Or}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.BinOpExpr PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.BinOpExpr PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.BinOpExpr PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.FloatLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.FloatLiteral PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.UnaryOpExpr PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.BinOpExpr PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.BinOpExpr PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE


.globl	potencia
.type	potencia, @function 
potencia: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $false, BoolLiteralLabel1(%rbp)

    mov false(%rbp), %eax
    mov -4(%rbp), %eax

    movl $1, IntLiteralLabel3(%rbp)

    mov 1(%rbp), %eax
    mov -12(%rbp), %eax

    movl $1.0, FloatLiteralLabel5(%rbp)

    mov 1.0(%rbp), %eax
    mov -20(%rbp), %eax

    movl $0, IntLiteralLabel8(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -36(%rbp)

    mov true(%rbp), %eax
    cmp -36(%rbp), %eax

    jne elseCondLabel11

    movl	$0, %eax 
	   negl	%eax 
    movl	%eax, -48(%rbp) 

    mov -0(%rbp), %eax
    mov -40(%rbp), %eax

    movl $true, BoolLiteralLabel15(%rbp)

    mov true(%rbp), %eax
    mov -52(%rbp), %eax

    jmp endIfLabel12

.elseCondLabel11

.endIfLabel12

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -68(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -80(%rbp)


.BeginWhileLabel25

    mov true(%rbp), %eax
    cmp -88(%rbp), %eax

    jne EndWhileLabel26


    movl $2, IntLiteralLabel30(%rbp)


    mov 0.0 * 0.0 * 2(%rbp), %eax
    mov -92(%rbp), %eax

    movl $1, IntLiteralLabel34(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-128%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -116(%rbp), %eax

    jmp BeginWhileLabel25

.EndWhileLabel26

    cmp $0, false(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -136(%rbp) 

    cmp $0, -136(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -144(%rbp) 

    mov true(%rbp), %eax
    cmp -144(%rbp), %eax

    jne elseCondLabel41

    movl $1.0, FloatLiteralLabel43(%rbp)

DIVIDE(/)

    mov VarLocation{name=factorLabel44, type=float, expr=1.0, size=0} / VarLocation{name=factorLabel45, type=float, expr=0.0, size=0}(%rbp), %eax

    jmp endIfLabel42

.elseCondLabel41

    mov 0.0(%rbp), %eax

.endIfLabel42

    movl $100.1, FloatLiteralLabel48(%rbp)


    mov -100.1(%rbp), %eax

    leave
    ret



.globl	multiples
.type	multiples, @function 
multiples: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $2.0, FloatLiteralLabel51(%rbp)


    mov -2.0(%rbp), %eax
    mov -4(%rbp), %eax

    movl $2, IntLiteralLabel54(%rbp)

    movl	$2, %eax 
	   negl	%eax 
    movl	%eax, -24(%rbp) 

    mov -2(%rbp), %eax
    mov -16(%rbp), %eax

    movl $3.0, FloatLiteralLabel57(%rbp)


    mov -3.0(%rbp), %eax
    mov -28(%rbp), %eax

    movl $3.0, FloatLiteralLabel60(%rbp)


    mov -3.0(%rbp), %eax
    mov -40(%rbp), %eax



    mov 0.0 * 0.0 - 0.0(%rbp), %eax
    mov -52(%rbp), %eax

    movl $0, IntLiteralLabel68(%rbp)

    mov 0(%rbp), %eax
    mov -76(%rbp), %eax

    movl $0, IntLiteralLabel70(%rbp)

    mov 0(%rbp), %eax
    mov -84(%rbp), %eax

    movl $0, IntLiteralLabel72(%rbp)

    mov 0(%rbp), %eax
    mov -92(%rbp), %eax

    movl $5, IntLiteralLabel74(%rbp)

    mov 5(%rbp), %eax
    mov -100(%rbp), %eax

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -116(%rbp)

    mov true(%rbp), %eax
    cmp -116(%rbp), %eax

    jne elseCondLabel79

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -128(%rbp)

    mov true(%rbp), %eax
    cmp -128(%rbp), %eax

    jne elseCondLabel84

    mov 0.0(%rbp), %eax
    mov -132(%rbp), %eax

    jmp endIfLabel85

.elseCondLabel84

    mov 0.0(%rbp), %eax
    mov -140(%rbp), %eax

.endIfLabel85

    jmp endIfLabel80

.elseCondLabel79

    movl	$0, %eax
    cmpl	$0, %eax
    setle %al
    movzbl %al, %eax
    movl	%eax, -156(%rbp)

.BeginWhileLabel92

    mov true(%rbp), %eax
    cmp -160(%rbp), %eax

    jne EndWhileLabel93

    movl	$0, %eax
    cmpl	$0, %eax
    setle %al
    movzbl %al, %eax
    movl	%eax, -172(%rbp)

.BeginWhileLabel97

    mov true(%rbp), %eax
    cmp -172(%rbp), %eax

    jne EndWhileLabel98

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -184(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -196(%rbp)


.BeginWhileLabel109

    mov true(%rbp), %eax
    cmp -212(%rbp), %eax

    jne EndWhileLabel110

    movl $3, IntLiteralLabel112(%rbp)

    movl	$0, %eax
    cmpl	$3, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -224(%rbp)

    mov true(%rbp), %eax
    cmp -224(%rbp), %eax

    jne elseCondLabel115

    movl $2.0, FloatLiteralLabel118(%rbp)


    mov 0.0 + 2.0(%rbp), %eax
    mov -228(%rbp), %eax

    jmp endIfLabel116

.elseCondLabel115

    movl $10.0, FloatLiteralLabel122(%rbp)

    movl $2.0, FloatLiteralLabel124(%rbp)

DIVIDE(/)


    mov 0.0 - VarLocation{name=DIVIDELabel126, type=float, expr=VarLocation{name=factorLabel123, type=float, expr=10.0, size=0} / VarLocation{name=factorLabel125, type=float, expr=2.0, size=0}, size=0}(%rbp), %eax
    mov -244(%rbp), %eax

.endIfLabel116

    movl $1, IntLiteralLabel129(%rbp)

    mov 1(%rbp), %eax
    mov -272(%rbp), %eax

    jmp BeginWhileLabel109

.EndWhileLabel110

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -288(%rbp)

    movl $0.0, FloatLiteralLabel134(%rbp)

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -300(%rbp)


    mov true(%rbp), %eax
    cmp -304(%rbp), %eax

    jne elseCondLabel139

    movl $35.0, FloatLiteralLabel141(%rbp)

    movl $4.0, FloatLiteralLabel143(%rbp)



    movl $498.0, FloatLiteralLabel148(%rbp)


    mov 35.0 + 4.0 * 0.0 - 498.0(%rbp), %eax
    mov -308(%rbp), %eax

    jmp endIfLabel140

.elseCondLabel139

    movl $3.2, FloatLiteralLabel151(%rbp)


    movl $12345.356, FloatLiteralLabel155(%rbp)


    mov 3.2 - 0.0 - 12345.356(%rbp), %eax
    mov -340(%rbp), %eax

.endIfLabel140

    movl $1, IntLiteralLabel159(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-376%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -364(%rbp), %eax

    jmp BeginWhileLabel97

.EndWhileLabel98



    movl $23.0, FloatLiteralLabel166(%rbp)



    movl $2.0, FloatLiteralLabel171(%rbp)

    movl $4.0, FloatLiteralLabel173(%rbp)

DIVIDE(/)


    mov 0.0 * -0.0 + 23.0 * 0.0 + VarLocation{name=factorLabel172, type=float, expr=2.0, size=0} / VarLocation{name=factorLabel174, type=float, expr=4.0, size=0}(%rbp), %eax
    mov -380(%rbp), %eax

    movl $1, IntLiteralLabel178(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-444%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -432(%rbp), %eax

    jmp BeginWhileLabel92

.EndWhileLabel93

.endIfLabel80


    mov -0.0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $80.0, FloatLiteralLabel183(%rbp)

    mov 80.0(%rbp), %eax
    mov -4(%rbp), %eax

    movl $15.0, FloatLiteralLabel185(%rbp)


    mov -15.0(%rbp), %eax
    mov -12(%rbp), %eax

    movl $4.3, FloatLiteralLabel188(%rbp)

    mov 4.3(%rbp), %eax
    mov -24(%rbp), %eax

    movl $7.6, FloatLiteralLabel190(%rbp)


    mov -7.6(%rbp), %eax
    mov -32(%rbp), %eax

    movl $2, IntLiteralLabel194(%rbp)

    call potencia
    movl %eax, RESULTLabel196(%rbp) 

PARAM

PARAM

    mov MethodCallExpr{name=potencia, args=[0.0, 2]}(%rbp), %eax
    mov -44(%rbp), %eax

    movl $2.0, FloatLiteralLabel200(%rbp)


    call multiples
    movl %eax, RESULTLabel203(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel205(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_float04.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -36
OFFSET = -40
OFFSET = -48
OFFSET = -52
OFFSET = -68
OFFSET = -80
OFFSET = -84
OFFSET = -92
OFFSET = -104
OFFSET = -112
OFFSET = -116
OFFSET = -128
OFFSET = -136
OFFSET = -144
OFFSET = -156
OFFSET = -168
OFFSET = -4
OFFSET = -16
OFFSET = -24
OFFSET = -32
OFFSET = -40
OFFSET = -48
OFFSET = -4
OFFSET = -12
OFFSET = -16
OFFSET = -24
OFFSET = -32
OFFSET = -36
OFFSET = -44

parseo exitoso
tamaño lista de codigo tercetos: 81
lista: 
{LABEL, null, null, Result: BeginMethod potencia}

{METHODDECL, Metodo{ name=potencia, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=x, value=null, size=0}, Simbolo{type=int, name=n, value=null, size=0}]}, null, Result: null}
{null, false, null, Result: BoolLiteralLabel1}
{ASSIGN(=), false, null, Result: VarLocation{name=neg, type=boolean, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel3}
{ASSIGN(=), 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 1.0, null, Result: FloatLiteralLabel5}
{ASSIGN(=), 1.0, null, Result: VarLocation{name=prod, type=float, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel8}
{LE(<), 0, 0, Result: VarLocation{name=LELabel10, type=boolean, expr=0 < 0, size=0}}
{CMP, VarLocation{name=LELabel10, type=boolean, expr=0 < 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel11}
{UNARYMINUS(-expr), 0, null, Result: VarLocation{name=UNARYMINUSLabel14, type=int, expr=-0, size=0}}
{ASSIGN(=), -0, null, Result: VarLocation{name=n, type=int, expr=null, size=0}}
{null, true, null, Result: BoolLiteralLabel15}
{ASSIGN(=), true, null, Result: VarLocation{name=neg, type=boolean, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel12}
{LABEL, null, null, Result: elseCondLabel11}
{LABEL, null, null, Result: endIfLabel12}
{LE(<), 0, 0, Result: VarLocation{name=LELabel19, type=boolean, expr=0 < 0, size=0}}
{CEQ(==), 0, 0, Result: VarLocation{name=CEQLabel22, type=boolean, expr=0 == 0, size=0}}
{OR(||), 0 < 0, 0 == 0, Result: VarLocation{name=DISYUNCIONLabel23, type=boolean, expr=0 < 0 || 0 == 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel25}
{CMP, VarLocation{name=factorLabel24, type=boolean, expr=VarLocation{name=DISYUNCIONLabel23, type=boolean, expr=0 < 0 || 0 == 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel26}
{MULTIPLY(*), 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel29, type=int, expr=0.0 * 0.0, size=0}}
{null, 2.0, null, Result: FloatLiteralLabel30}
{MULTIPLY(*), 0.0 * 0.0, 2.0, Result: VarLocation{name=MULTIPLYLabel32, type=int, expr=0.0 * 0.0 * 2.0, size=0}}
{ASSIGN(=), 0.0 * 0.0 * 2.0, null, Result: VarLocation{name=prod, type=float, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel34}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel36, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel25}
{LABEL, null, null, Result: EndWhileLabel26}
{NON(!), false, null, Result: VarLocation{name=NONLabel38, type=boolean, expr=!false, size=0}}
{NON(!), VarLocation{name=NONLabel38, type=boolean, expr=!false, size=0}, null, Result: VarLocation{name=NONLabel40, type=boolean, expr=!VarLocation{name=NONLabel38, type=boolean, expr=!false, size=0}, size=0}}
{CMP, VarLocation{name=NONLabel40, type=boolean, expr=!VarLocation{name=NONLabel38, type=boolean, expr=!false, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel41}
{null, 1.0, null, Result: FloatLiteralLabel43}
{DIVIDE(/), 1.0, 0.0, Result: VarLocation{name=DIVIDELabel46, type=float, expr=VarLocation{name=factorLabel44, type=float, expr=1.0, size=0} / VarLocation{name=factorLabel45, type=float, expr=0.0, size=0}, size=0}}
{RETURN, null, null, Result: VarLocation{name=factorLabel44, type=float, expr=1.0, size=0} / VarLocation{name=factorLabel45, type=float, expr=0.0, size=0}}
{JMP, null, null, Result: endIfLabel42}
{LABEL, null, null, Result: elseCondLabel41}
{RETURN, null, null, Result: 0.0}
{LABEL, null, null, Result: endIfLabel42}
{null, 100.1, null, Result: FloatLiteralLabel48}
{UNARYMINUS(-expr), 100.1, null, Result: VarLocation{name=UNARYMINUSLabel50, type=float, expr=-100.1, size=0}}
{RETURN, null, null, Result: -100.1}
{LABEL, null, null, Result: EndMethod potencia}
{LABEL, null, null, Result: BeginMethod multRepeat}

{METHODDECL, Metodo{ name=multRepeat, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=b, value=null, size=0}, Simbolo{type=float, name=a, value=null, size=0}]}, null, Result: null}
{MULTIPLY(*), 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel53, type=int, expr=0.0 * 0.0, size=0}}
{MULTIPLY(*), 0.0 * 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel55, type=int, expr=0.0 * 0.0 * 0.0, size=0}}
{MULTIPLY(*), 0.0 * 0.0 * 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel57, type=int, expr=0.0 * 0.0 * 0.0 * 0.0, size=0}}
{MULTIPLY(*), 0.0 * 0.0 * 0.0 * 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel59, type=int, expr=0.0 * 0.0 * 0.0 * 0.0 * 0.0, size=0}}
{MULTIPLY(*), 0.0 * 0.0 * 0.0 * 0.0 * 0.0, 0.0, Result: VarLocation{name=MULTIPLYLabel61, type=int, expr=0.0 * 0.0 * 0.0 * 0.0 * 0.0 * 0.0, size=0}}
{ASSIGN(=), 0.0 * 0.0 * 0.0 * 0.0 * 0.0 * 0.0, null, Result: VarLocation{name=c, type=float, expr=null, size=0}}
{RETURN, null, null, Result: 0.0}
{LABEL, null, null, Result: EndMethod multRepeat}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{null, 15.0, null, Result: FloatLiteralLabel63}
{UNARYMINUS(-expr), 15.0, null, Result: VarLocation{name=UNARYMINUSLabel65, type=float, expr=-15.0, size=0}}
{ASSIGN(=), -15.0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{null, 4.3, null, Result: FloatLiteralLabel66}
{ASSIGN(=), 4.3, null, Result: VarLocation{name=w, type=float, expr=null, size=0}}
{null, 7.6, null, Result: FloatLiteralLabel68}
{UNARYMINUS(-expr), 7.6, null, Result: VarLocation{name=UNARYMINUSLabel70, type=float, expr=-7.6, size=0}}
{ASSIGN(=), -7.6, null, Result: VarLocation{name=m, type=float, expr=null, size=0}}
{null, 80.0, null, Result: FloatLiteralLabel71}
{ASSIGN(=), 80.0, null, Result: VarLocation{name=a, type=float, expr=null, size=0}}
{null, 2, null, Result: IntLiteralLabel74}
{METHODCALL, potencia, 2, Result: RESULTLabel76}
{PARAM, null, null, Result: 0.0}
{PARAM, null, null, Result: 2}
{ASSIGN(=), MethodCallExpr{name=potencia, args=[0.0, 2]}, null, Result: VarLocation{name=f, type=float, expr=null, size=0}}
{METHODCALL, multRepeat, 2, Result: RESULTLabel80}
{PARAM, null, null, Result: 0.0}
{PARAM, null, null, Result: 0.0}
{EXTERNINVK, ExternInvkExpr{id="printf", type=void, parameters=[StringLiteral{value="%f"}, MethodCallExpr{name=multRepeat, args=[0.0, 0.0]}]}, null, Result: EXTERNINVKLabel82}
{LABEL, null, null, Result: EndMethod main}

{Or}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.BinOpExpr PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.FloatLiteral PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.FloatLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.FloatLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.FloatLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.FloatLiteral PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)


.globl	potencia
.type	potencia, @function 
potencia: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $false, BoolLiteralLabel1(%rbp)

    mov false(%rbp), %eax
    mov -4(%rbp), %eax

    movl $1, IntLiteralLabel3(%rbp)

    mov 1(%rbp), %eax
    mov -12(%rbp), %eax

    movl $1.0, FloatLiteralLabel5(%rbp)

    mov 1.0(%rbp), %eax
    mov -20(%rbp), %eax

    movl $0, IntLiteralLabel8(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -36(%rbp)

    mov true(%rbp), %eax
    cmp -36(%rbp), %eax

    jne elseCondLabel11

    movl	$0, %eax 
	   negl	%eax 
    movl	%eax, -48(%rbp) 

    mov -0(%rbp), %eax
    mov -40(%rbp), %eax

    movl $true, BoolLiteralLabel15(%rbp)

    mov true(%rbp), %eax
    mov -52(%rbp), %eax

    jmp endIfLabel12

.elseCondLabel11

.endIfLabel12

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -68(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -80(%rbp)


.BeginWhileLabel25

    mov true(%rbp), %eax
    cmp -88(%rbp), %eax

    jne EndWhileLabel26


    movl $2.0, FloatLiteralLabel30(%rbp)


    mov 0.0 * 0.0 * 2.0(%rbp), %eax
    mov -92(%rbp), %eax

    movl $1, IntLiteralLabel34(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-128%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -116(%rbp), %eax

    jmp BeginWhileLabel25

.EndWhileLabel26

    cmp $0, false(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -136(%rbp) 

    cmp $0, -136(%rbp) 
    sete %al 
    movzbl %al, %eax 
    mov %eax, -144(%rbp) 

    mov true(%rbp), %eax
    cmp -144(%rbp), %eax

    jne elseCondLabel41

    movl $1.0, FloatLiteralLabel43(%rbp)

DIVIDE(/)

    mov VarLocation{name=factorLabel44, type=float, expr=1.0, size=0} / VarLocation{name=factorLabel45, type=float, expr=0.0, size=0}(%rbp), %eax

    jmp endIfLabel42

.elseCondLabel41

    mov 0.0(%rbp), %eax

.endIfLabel42

    movl $100.1, FloatLiteralLabel48(%rbp)


    mov -100.1(%rbp), %eax

    leave
    ret



.globl	multRepeat
.type	multRepeat, @function 
multRepeat: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp






    mov 0.0 * 0.0 * 0.0 * 0.0 * 0.0 * 0.0(%rbp), %eax
    mov -4(%rbp), %eax

    mov 0.0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $15.0, FloatLiteralLabel63(%rbp)


    mov -15.0(%rbp), %eax
    mov -4(%rbp), %eax

    movl $4.3, FloatLiteralLabel66(%rbp)

    mov 4.3(%rbp), %eax
    mov -16(%rbp), %eax

    movl $7.6, FloatLiteralLabel68(%rbp)


    mov -7.6(%rbp), %eax
    mov -24(%rbp), %eax

    movl $80.0, FloatLiteralLabel71(%rbp)

    mov 80.0(%rbp), %eax
    mov -36(%rbp), %eax

    movl $2, IntLiteralLabel74(%rbp)

    call potencia
    movl %eax, RESULTLabel76(%rbp) 

PARAM

PARAM

    mov MethodCallExpr{name=potencia, args=[0.0, 2]}(%rbp), %eax
    mov -44(%rbp), %eax

    call multRepeat
    movl %eax, RESULTLabel80(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel82(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_floats05.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -12
OFFSET = -12
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -24

parseo exitoso
tamaño lista de codigo tercetos: 35
lista: 
{LABEL, null, null, Result: BeginMethod div}

{METHODDECL, Metodo{ name=div, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=a, value=null, size=0}, Simbolo{type=float, name=b, value=null, size=0}]}, null, Result: null}
{DIVIDE(/), 0.0, 0.0, Result: VarLocation{name=DIVIDELabel3, type=float, expr=VarLocation{name=factorLabel1, type=float, expr=0.0, size=0} / VarLocation{name=factorLabel2, type=float, expr=0.0, size=0}, size=0}}
{RETURN, null, null, Result: VarLocation{name=factorLabel1, type=float, expr=0.0, size=0} / VarLocation{name=factorLabel2, type=float, expr=0.0, size=0}}
{LABEL, null, null, Result: EndMethod div}
{LABEL, null, null, Result: BeginMethod resta}

{METHODDECL, Metodo{ name=resta, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=a, value=null, size=0}, Simbolo{type=float, name=b, value=null, size=0}]}, null, Result: null}
{MINUS(-), 0.0, 0.0, Result: VarLocation{name=MINUSLabel6, type=float, expr=0.0 - 0.0, size=0}}
{RETURN, null, null, Result: 0.0 - 0.0}
{LABEL, null, null, Result: EndMethod resta}
{LABEL, null, null, Result: BeginMethod sum}

{METHODDECL, Metodo{ name=sum, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=a, value=null, size=0}, Simbolo{type=float, name=b, value=null, size=0}]}, null, Result: null}
{PLUS(+), 0.0, 0.0, Result: VarLocation{name=PLUSLabel9, type=float, expr=0.0 + 0.0, size=0}}
{RETURN, null, null, Result: 0.0 + 0.0}
{LABEL, null, null, Result: EndMethod sum}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{null, 6.982, null, Result: FloatLiteralLabel10}
{ASSIGN(=), 6.982, null, Result: VarLocation{name=x, type=float, expr=null, size=0}}
{null, 002.5, null, Result: FloatLiteralLabel12}
{UNARYMINUS(-expr), 002.5, null, Result: VarLocation{name=UNARYMINUSLabel14, type=float, expr=-002.5, size=0}}
{ASSIGN(=), -002.5, null, Result: VarLocation{name=y, type=float, expr=null, size=0}}
{null, 3.5698, null, Result: FloatLiteralLabel15}
{ASSIGN(=), 3.5698, null, Result: VarLocation{name=z, type=float, expr=null, size=0}}
{METHODCALL, resta, 2, Result: RESULTLabel19}
{PARAM, null, null, Result: 0.0}
{PARAM, null, null, Result: 0.0}
{METHODCALL, div, 2, Result: RESULTLabel23}
{PARAM, null, null, Result: 0.0}
{PARAM, null, null, Result: 0.0}
{METHODCALL, sum, 2, Result: RESULTLabel25}
{PARAM, null, null, Result: MethodCallExpr{name=resta, args=[0.0, 0.0]}}
{PARAM, null, null, Result: MethodCallExpr{name=div, args=[0.0, 0.0]}}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[StringLiteral{value="anidandofuncionesflotantes"}, MethodCallExpr{name=sum, args=[MethodCallExpr{name=resta, args=[0.0, 0.0]}, MethodCallExpr{name=div, args=[0.0, 0.0]}]}]}, null, Result: EXTERNINVKLabel27}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Unary_Minus}IMPLEMENTAR CASO -(FLOAT)


.globl	div
.type	div, @function 
div: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

DIVIDE(/)

    mov VarLocation{name=factorLabel1, type=float, expr=0.0, size=0} / VarLocation{name=factorLabel2, type=float, expr=0.0, size=0}(%rbp), %eax

    leave
    ret



.globl	resta
.type	resta, @function 
resta: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp


    mov 0.0 - 0.0(%rbp), %eax

    leave
    ret



.globl	sum
.type	sum, @function 
sum: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp


    mov 0.0 + 0.0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $6.982, FloatLiteralLabel10(%rbp)

    mov 6.982(%rbp), %eax
    mov -4(%rbp), %eax

    movl $002.5, FloatLiteralLabel12(%rbp)


    mov -002.5(%rbp), %eax
    mov -12(%rbp), %eax

    movl $3.5698, FloatLiteralLabel15(%rbp)

    mov 3.5698(%rbp), %eax
    mov -24(%rbp), %eax

    call resta
    movl %eax, RESULTLabel19(%rbp) 

PARAM

PARAM

    call div
    movl %eax, RESULTLabel23(%rbp) 

PARAM

PARAM

    call sum
    movl %eax, RESULTLabel25(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel27(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_for01.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -36
OFFSET = -44
OFFSET = -56

parseo exitoso
tamaño lista de codigo tercetos: 32
lista: 
{LABEL, null, null, Result: BeginMethod pruArreglos}

{METHODDECL, Metodo{ name=pruArreglos, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel1}
{null, 2, null, Result: IntLiteralLabel3}
{ASSIGN(=), 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{null, 1, null, Result: IntLiteralLabel5}
{ARRAYACCESS, A, VarLocation{name=factorLabel6, type=int, expr=1, size=0}, Result: ArrayAccessLabel7}
{RETURN, null, null, Result: ArrayLiteral{id=A, size=5}}
{null, 5, null, Result: IntLiteralLabel9}
{null, 10, null, Result: IntLiteralLabel12}
{MULTIPLY(*), 0, 10, Result: VarLocation{name=MULTIPLYLabel14, type=int, expr=0 * 10, size=0}}
{LABEL, null, null, Result: BeginForLabel15}
{CMP, VarLocation{name=factorLabel10, type=int, expr=5, size=0}, VarLocation{name=MULTIPLYLabel14, type=int, expr=0 * 10, size=0}, Result: null}
{JNL, null, null, Result: EndForLabel16}
{null, 2, null, Result: IntLiteralLabel19}
{PLUS(+), 0, 2, Result: VarLocation{name=PLUSLabel21, type=int, expr=0 + 2, size=0}}
{ASSIGN(=), 0 + 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{PLUS(+), VarLocation{name=factorLabel10, type=int, expr=5, size=0}, 1, Result: VarLocation{name=factorLabel10, type=int, expr=5, size=0}}
{JMP, null, null, Result: BeginForLabel15}
{LABEL, null, null, Result: EndForLabel16}
{LABEL, null, null, Result: EndMethod pruArreglos}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel22}
{null, 8, null, Result: IntLiteralLabel24}
{METHODCALL, pruArreglos, 2, Result: RESULTLabel26}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[StringLiteral{value="%d resultado : "}, MethodCallExpr{name=pruArreglos, args=[4, 8]}]}, null, Result: EXTERNINVKLabel28}
{null, 1, null, Result: IntLiteralLabel29}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class java.lang.String PENDIENTE


.globl	pruArreglos
.type	pruArreglos, @function 
pruArreglos: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel1(%rbp)

    movl $2, IntLiteralLabel3(%rbp)

    mov 2(%rbp), %eax
    mov -8(%rbp), %eax

    movl $1, IntLiteralLabel5(%rbp)

ARRAYACCESS

    mov ArrayLiteral{id=A, size=5}(%rbp), %eax

    movl $5, IntLiteralLabel9(%rbp)

    movl $10, IntLiteralLabel12(%rbp)

    mov $0, %eax
    mov $10, %edx
    imul %edx, %eax
    mov %eax,-36%(ebp)

.BeginForLabel15

    mov -36(%rbp), %eax
    cmp -24(%rbp), %eax

    jnl EndForLabel16

    movl $2, IntLiteralLabel19(%rbp)

    mov $0, %eax 
    mov $2, %edx 
    add %eax, %edx 
    mov %edx,-56%(ebp) 

    mov 0 + 2(%rbp), %eax
    mov -44(%rbp), %eax


    jmp BeginForLabel15

.EndForLabel16

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel22(%rbp)

    movl $8, IntLiteralLabel24(%rbp)

    call pruArreglos
    movl %eax, RESULTLabel26(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel28(%rbp) 

    movl $1, IntLiteralLabel29(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_for02.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -36
OFFSET = -48

parseo exitoso
tamaño lista de codigo tercetos: 31
lista: 
{LABEL, null, null, Result: BeginMethod pruArreglos}

{METHODDECL, Metodo{ name=pruArreglos, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel1}
{null, 2, null, Result: IntLiteralLabel3}
{ASSIGN(=), 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{null, 1, null, Result: IntLiteralLabel5}
{ARRAYACCESS, A, VarLocation{name=factorLabel6, type=int, expr=1, size=0}, Result: ArrayAccessLabel7}
{RETURN, null, null, Result: ArrayLiteral{id=A, size=5}}
{null, 5, null, Result: IntLiteralLabel9}
{null, 10, null, Result: IntLiteralLabel11}
{LABEL, null, null, Result: BeginForLabel13}
{CMP, VarLocation{name=factorLabel10, type=int, expr=5, size=0}, VarLocation{name=factorLabel12, type=int, expr=10, size=0}, Result: null}
{JNL, null, null, Result: EndForLabel14}
{null, 2, null, Result: IntLiteralLabel17}
{PLUS(+), 0, 2, Result: VarLocation{name=PLUSLabel19, type=int, expr=0 + 2, size=0}}
{ASSIGN(=), 0 + 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{PLUS(+), VarLocation{name=factorLabel10, type=int, expr=5, size=0}, 1, Result: VarLocation{name=factorLabel10, type=int, expr=5, size=0}}
{JMP, null, null, Result: BeginForLabel13}
{LABEL, null, null, Result: EndForLabel14}
{LABEL, null, null, Result: EndMethod pruArreglos}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel20}
{null, 8, null, Result: IntLiteralLabel22}
{METHODCALL, pruArreglos, 2, Result: RESULTLabel24}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[StringLiteral{value="%d resultado : "}, MethodCallExpr{name=pruArreglos, args=[4, 8]}]}, null, Result: EXTERNINVKLabel26}
{null, 1, null, Result: IntLiteralLabel27}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class java.lang.String PENDIENTE


.globl	pruArreglos
.type	pruArreglos, @function 
pruArreglos: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel1(%rbp)

    movl $2, IntLiteralLabel3(%rbp)

    mov 2(%rbp), %eax
    mov -8(%rbp), %eax

    movl $1, IntLiteralLabel5(%rbp)

ARRAYACCESS

    mov ArrayLiteral{id=A, size=5}(%rbp), %eax

    movl $5, IntLiteralLabel9(%rbp)

    movl $10, IntLiteralLabel11(%rbp)

.BeginForLabel13

    mov -28(%rbp), %eax
    cmp -24(%rbp), %eax

    jnl EndForLabel14

    movl $2, IntLiteralLabel17(%rbp)

    mov $0, %eax 
    mov $2, %edx 
    add %eax, %edx 
    mov %edx,-48%(ebp) 

    mov 0 + 2(%rbp), %eax
    mov -36(%rbp), %eax


    jmp BeginForLabel13

.EndForLabel14

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel20(%rbp)

    movl $8, IntLiteralLabel22(%rbp)

    call pruArreglos
    movl %eax, RESULTLabel24(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel26(%rbp) 

    movl $1, IntLiteralLabel27(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_for03.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -32
OFFSET = -40
OFFSET = -52

parseo exitoso
tamaño lista de codigo tercetos: 32
lista: 
{LABEL, null, null, Result: BeginMethod pruArreglos}

{METHODDECL, Metodo{ name=pruArreglos, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel1}
{null, 2, null, Result: IntLiteralLabel3}
{ASSIGN(=), 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{null, 1, null, Result: IntLiteralLabel5}
{ARRAYACCESS, A, VarLocation{name=factorLabel6, type=int, expr=1, size=0}, Result: ArrayAccessLabel7}
{RETURN, null, null, Result: ArrayLiteral{id=A, size=5}}
{null, 5, null, Result: IntLiteralLabel9}
{null, 10, null, Result: IntLiteralLabel11}
{UNARYMINUS(-expr), 10, null, Result: VarLocation{name=UNARYMINUSLabel13, type=int, expr=-10, size=0}}
{LABEL, null, null, Result: BeginForLabel14}
{CMP, VarLocation{name=factorLabel10, type=int, expr=5, size=0}, VarLocation{name=UNARYMINUSLabel13, type=int, expr=-10, size=0}, Result: null}
{JNL, null, null, Result: EndForLabel15}
{null, 2, null, Result: IntLiteralLabel18}
{PLUS(+), 0, 2, Result: VarLocation{name=PLUSLabel20, type=int, expr=0 + 2, size=0}}
{ASSIGN(=), 0 + 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{PLUS(+), VarLocation{name=factorLabel10, type=int, expr=5, size=0}, 1, Result: VarLocation{name=factorLabel10, type=int, expr=5, size=0}}
{JMP, null, null, Result: BeginForLabel14}
{LABEL, null, null, Result: EndForLabel15}
{LABEL, null, null, Result: EndMethod pruArreglos}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel21}
{null, 8, null, Result: IntLiteralLabel23}
{METHODCALL, pruArreglos, 2, Result: RESULTLabel25}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[StringLiteral{value="%d resultado : "}, MethodCallExpr{name=pruArreglos, args=[4, 8]}]}, null, Result: EXTERNINVKLabel27}
{null, 1, null, Result: IntLiteralLabel28}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class java.lang.String PENDIENTE


.globl	pruArreglos
.type	pruArreglos, @function 
pruArreglos: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel1(%rbp)

    movl $2, IntLiteralLabel3(%rbp)

    mov 2(%rbp), %eax
    mov -8(%rbp), %eax

    movl $1, IntLiteralLabel5(%rbp)

ARRAYACCESS

    mov ArrayLiteral{id=A, size=5}(%rbp), %eax

    movl $5, IntLiteralLabel9(%rbp)

    movl $10, IntLiteralLabel11(%rbp)

    movl	$10, %eax 
	   negl	%eax 
    movl	%eax, -32(%rbp) 

.BeginForLabel14

    mov -32(%rbp), %eax
    cmp -24(%rbp), %eax

    jnl EndForLabel15

    movl $2, IntLiteralLabel18(%rbp)

    mov $0, %eax 
    mov $2, %edx 
    add %eax, %edx 
    mov %edx,-52%(ebp) 

    mov 0 + 2(%rbp), %eax
    mov -40(%rbp), %eax


    jmp BeginForLabel14

.EndForLabel15

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel21(%rbp)

    movl $8, IntLiteralLabel23(%rbp)

    call pruArreglos
    movl %eax, RESULTLabel25(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel27(%rbp) 

    movl $1, IntLiteralLabel28(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_for04.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -32
OFFSET = -44
OFFSET = -48
OFFSET = -60
OFFSET = -72

parseo exitoso
tamaño lista de codigo tercetos: 36
lista: 
{LABEL, null, null, Result: BeginMethod pruArreglos}

{METHODDECL, Metodo{ name=pruArreglos, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel1}
{null, 2, null, Result: IntLiteralLabel3}
{ASSIGN(=), 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{null, 1, null, Result: IntLiteralLabel5}
{ARRAYACCESS, A, VarLocation{name=factorLabel6, type=int, expr=1, size=0}, Result: ArrayAccessLabel7}
{RETURN, null, null, Result: ArrayLiteral{id=A, size=5}}
{null, 0, null, Result: IntLiteralLabel9}
{null, 10, null, Result: IntLiteralLabel11}
{UNARYMINUS(-expr), 10, null, Result: VarLocation{name=UNARYMINUSLabel13, type=int, expr=-10, size=0}}
{null, 11, null, Result: IntLiteralLabel14}
{null, 2, null, Result: IntLiteralLabel16}
{MULTIPLY(*), 11, 2, Result: VarLocation{name=MULTIPLYLabel18, type=int, expr=11 * 2, size=0}}
{PLUS(+), -10, 11 * 2, Result: VarLocation{name=PLUSLabel19, type=int, expr=-10 + 11 * 2, size=0}}
{LABEL, null, null, Result: BeginForLabel21}
{CMP, VarLocation{name=factorLabel10, type=int, expr=0, size=0}, VarLocation{name=factorLabel20, type=int, expr=VarLocation{name=PLUSLabel19, type=int, expr=-10 + 11 * 2, size=0}, size=0}, Result: null}
{JNL, null, null, Result: EndForLabel22}
{null, 2, null, Result: IntLiteralLabel25}
{PLUS(+), 0, 2, Result: VarLocation{name=PLUSLabel27, type=int, expr=0 + 2, size=0}}
{ASSIGN(=), 0 + 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{PLUS(+), VarLocation{name=factorLabel10, type=int, expr=0, size=0}, 1, Result: VarLocation{name=factorLabel10, type=int, expr=0, size=0}}
{JMP, null, null, Result: BeginForLabel21}
{LABEL, null, null, Result: EndForLabel22}
{LABEL, null, null, Result: EndMethod pruArreglos}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel28}
{null, 8, null, Result: IntLiteralLabel30}
{METHODCALL, pruArreglos, 2, Result: RESULTLabel32}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[StringLiteral{value="%d resultado : "}, MethodCallExpr{name=pruArreglos, args=[4, 8]}]}, null, Result: EXTERNINVKLabel34}
{null, 1, null, Result: IntLiteralLabel35}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.UnaryOpExpr y class ir.ast.BinOpExpr PENDIENTE
{Add}TRATAMIENTO PARA class java.lang.String PENDIENTE


.globl	pruArreglos
.type	pruArreglos, @function 
pruArreglos: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel1(%rbp)

    movl $2, IntLiteralLabel3(%rbp)

    mov 2(%rbp), %eax
    mov -8(%rbp), %eax

    movl $1, IntLiteralLabel5(%rbp)

ARRAYACCESS

    mov ArrayLiteral{id=A, size=5}(%rbp), %eax

    movl $0, IntLiteralLabel9(%rbp)

    movl $10, IntLiteralLabel11(%rbp)

    movl	$10, %eax 
	   negl	%eax 
    movl	%eax, -32(%rbp) 

    movl $11, IntLiteralLabel14(%rbp)

    movl $2, IntLiteralLabel16(%rbp)

    mov $11, %eax
    mov $2, %edx
    imul %edx, %eax
    mov %eax,-44%(ebp)


.BeginForLabel21

    mov -52(%rbp), %eax
    cmp -24(%rbp), %eax

    jnl EndForLabel22

    movl $2, IntLiteralLabel25(%rbp)

    mov $0, %eax 
    mov $2, %edx 
    add %eax, %edx 
    mov %edx,-72%(ebp) 

    mov 0 + 2(%rbp), %eax
    mov -60(%rbp), %eax


    jmp BeginForLabel21

.EndForLabel22

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel28(%rbp)

    movl $8, IntLiteralLabel30(%rbp)

    call pruArreglos
    movl %eax, RESULTLabel32(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel34(%rbp) 

    movl $1, IntLiteralLabel35(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_for05.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -36
OFFSET = -44
OFFSET = -56

parseo exitoso
tamaño lista de codigo tercetos: 38
lista: 
{LABEL, null, null, Result: BeginMethod par}

{METHODDECL, Metodo{ name=par, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 15, null, Result: IntLiteralLabel1}
{RETURN, null, null, Result: 15}
{LABEL, null, null, Result: EndMethod par}
{LABEL, null, null, Result: BeginMethod pruArreglos}

{METHODDECL, Metodo{ name=pruArreglos, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel3}
{null, 2, null, Result: IntLiteralLabel5}
{ASSIGN(=), 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{null, 1, null, Result: IntLiteralLabel7}
{ARRAYACCESS, A, VarLocation{name=factorLabel8, type=int, expr=1, size=0}, Result: ArrayAccessLabel9}
{RETURN, null, null, Result: ArrayLiteral{id=A, size=5}}
{METHODCALL, par, 0, Result: RESULTLabel11}
{METHODCALL, par, 0, Result: RESULTLabel13}
{null, 5, null, Result: IntLiteralLabel15}
{PLUS(+), MethodCallExpr{name=par, args=[]}, 5, Result: VarLocation{name=PLUSLabel17, type=int, expr=MethodCallExpr{name=par, args=[]} + 5, size=0}}
{LABEL, null, null, Result: BeginForLabel18}
{CMP, VarLocation{name=factorLabel12, type=int, expr=MethodCallExpr{name=par, args=[]}, size=0}, VarLocation{name=PLUSLabel17, type=int, expr=MethodCallExpr{name=par, args=[]} + 5, size=0}, Result: null}
{JNL, null, null, Result: EndForLabel19}
{null, 2, null, Result: IntLiteralLabel22}
{PLUS(+), 0, 2, Result: VarLocation{name=PLUSLabel24, type=int, expr=0 + 2, size=0}}
{ASSIGN(=), 0 + 2, null, Result: VarLocation{name=A, type=int[], expr=null, size=5}}
{PLUS(+), VarLocation{name=factorLabel12, type=int, expr=MethodCallExpr{name=par, args=[]}, size=0}, 1, Result: VarLocation{name=factorLabel12, type=int, expr=MethodCallExpr{name=par, args=[]}, size=0}}
{JMP, null, null, Result: BeginForLabel18}
{LABEL, null, null, Result: EndForLabel19}
{LABEL, null, null, Result: EndMethod pruArreglos}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel25}
{null, 8, null, Result: IntLiteralLabel27}
{METHODCALL, pruArreglos, 2, Result: RESULTLabel29}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[StringLiteral{value="%d resultado : "}, MethodCallExpr{name=pruArreglos, args=[4, 8]}]}, null, Result: EXTERNINVKLabel31}
{null, 1, null, Result: IntLiteralLabel32}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.MethodCallExpr y class ir.ast.IntLiteral PENDIENTE
{Add}TRATAMIENTO PARA class java.lang.String PENDIENTE


.globl	par
.type	par, @function 
par: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $15, IntLiteralLabel1(%rbp)

    mov 15(%rbp), %eax

    leave
    ret



.globl	pruArreglos
.type	pruArreglos, @function 
pruArreglos: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel3(%rbp)

    movl $2, IntLiteralLabel5(%rbp)

    mov 2(%rbp), %eax
    mov -8(%rbp), %eax

    movl $1, IntLiteralLabel7(%rbp)

ARRAYACCESS

    mov ArrayLiteral{id=A, size=5}(%rbp), %eax

    call par
    movl %eax, RESULTLabel11(%rbp) 

    call par
    movl %eax, RESULTLabel13(%rbp) 

    movl $5, IntLiteralLabel15(%rbp)


.BeginForLabel18

    mov -36(%rbp), %eax
    cmp -24(%rbp), %eax

    jnl EndForLabel19

    movl $2, IntLiteralLabel22(%rbp)

    mov $0, %eax 
    mov $2, %edx 
    add %eax, %edx 
    mov %edx,-56%(ebp) 

    mov 0 + 2(%rbp), %eax
    mov -44(%rbp), %eax


    jmp BeginForLabel18

.EndForLabel19

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel25(%rbp)

    movl $8, IntLiteralLabel27(%rbp)

    call pruArreglos
    movl %eax, RESULTLabel29(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel31(%rbp) 

    movl $1, IntLiteralLabel32(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_if_anidados.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -24
OFFSET = -28
OFFSET = -40
OFFSET = -44
OFFSET = -56
OFFSET = -60
OFFSET = -72
Error: Method pruAritmetica must return int

parseo exitoso
tamaño lista de codigo tercetos: 44
lista: 
{LABEL, null, null, Result: BeginMethod pruAritmetica}

{METHODDECL, Metodo{ name=pruAritmetica, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{NEQ(!=), 0, 0, Result: VarLocation{name=NEQLabel3, type=boolean, expr=0 != 0, size=0}}
{CMP, VarLocation{name=NEQLabel3, type=boolean, expr=0 != 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel4}
{GE(>), 0, 0, Result: VarLocation{name=GELabel8, type=boolean, expr=0 > 0, size=0}}
{CMP, VarLocation{name=GELabel8, type=boolean, expr=0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel9}
{MINUS(-), 0, 0, Result: VarLocation{name=MINUSLabel13, type=int, expr=0 - 0, size=0}}
{ASSIGN(=), 0 - 0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel10}
{LABEL, null, null, Result: elseCondLabel9}
{MINUS(-), 0, 0, Result: VarLocation{name=MINUSLabel16, type=int, expr=0 - 0, size=0}}
{ASSIGN(=), 0 - 0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel10}
{JMP, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: elseCondLabel4}
{null, 5, null, Result: IntLiteralLabel18}
{MULTIPLY(*), 0, 5, Result: VarLocation{name=MULTIPLYLabel20, type=int, expr=0 * 5, size=0}}
{ASSIGN(=), 0 * 5, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: EndMethod pruAritmetica}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel22}
{null, 8, null, Result: IntLiteralLabel24}
{METHODCALL, pruAritmetica, 2, Result: RESULTLabel26}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[4, 8]}]}, null, Result: EXTERNINVKLabel28}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[]}, null, Result: EXTERNINVKLabel29}
{null, 4, null, Result: IntLiteralLabel30}
{null, 4, null, Result: IntLiteralLabel32}
{METHODCALL, pruAritmetica, 2, Result: RESULTLabel34}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 4}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[4, 4]}]}, null, Result: EXTERNINVKLabel36}
{null, 8, null, Result: IntLiteralLabel37}
{null, 5, null, Result: IntLiteralLabel39}
{METHODCALL, pruAritmetica, 2, Result: RESULTLabel41}
{PARAM, null, null, Result: 8}
{PARAM, null, null, Result: 5}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[8, 5]}]}, null, Result: EXTERNINVKLabel43}
{LABEL, null, null, Result: EndMethod main}



.globl	pruAritmetica
.type	pruAritmetica, @function 
pruAritmetica: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl	$0, %eax
    cmpl	$0, %eax
    setgne %al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    mov true(%rbp), %eax
    cmp -12(%rbp), %eax

    jne elseCondLabel4

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -24(%rbp)

    mov true(%rbp), %eax
    cmp -24(%rbp), %eax

    jne elseCondLabel9

    mov $0, %eax
    mov $0, %edx
    sub %eax, %edx
    mov %edx,-40%(ebp)

    mov 0 - 0(%rbp), %eax
    mov -28(%rbp), %eax

    jmp endIfLabel10

.elseCondLabel9

    mov $0, %eax
    mov $0, %edx
    sub %eax, %edx
    mov %edx,-56%(ebp)

    mov 0 - 0(%rbp), %eax
    mov -44(%rbp), %eax

.endIfLabel10

    jmp endIfLabel5

.elseCondLabel4

    movl $5, IntLiteralLabel18(%rbp)

    mov $0, %eax
    mov $5, %edx
    imul %edx, %eax
    mov %eax,-72%(ebp)

    mov 0 * 5(%rbp), %eax
    mov -60(%rbp), %eax

.endIfLabel5

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel22(%rbp)

    movl $8, IntLiteralLabel24(%rbp)

    call pruAritmetica
    movl %eax, RESULTLabel26(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel28(%rbp) 

    call "printf"
    movl %eax, EXTERNINVKLabel29(%rbp) 

    movl $4, IntLiteralLabel30(%rbp)

    movl $4, IntLiteralLabel32(%rbp)

    call pruAritmetica
    movl %eax, RESULTLabel34(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel36(%rbp) 

    movl $8, IntLiteralLabel37(%rbp)

    movl $5, IntLiteralLabel39(%rbp)

    call pruAritmetica
    movl %eax, RESULTLabel41(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel43(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_if.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -16
OFFSET = -28
OFFSET = -40
OFFSET = -44
OFFSET = -56
OFFSET = -60
OFFSET = -72
Error: Method pruAritmetica must return int

parseo exitoso
tamaño lista de codigo tercetos: 44
lista: 
{LABEL, null, null, Result: BeginMethod pruAritmetica}

{METHODDECL, Metodo{ name=pruAritmetica, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=b, value=null, size=0}, Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{GE(>), 0, 0, Result: VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}}
{CMP, VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel4}
{MINUS(-), 0, 0, Result: VarLocation{name=MINUSLabel8, type=int, expr=0 - 0, size=0}}
{ASSIGN(=), 0 - 0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: elseCondLabel4}
{LABEL, null, null, Result: endIfLabel5}
{CEQ(==), 0, 0, Result: VarLocation{name=CEQLabel11, type=boolean, expr=0 == 0, size=0}}
{CMP, VarLocation{name=CEQLabel11, type=boolean, expr=0 == 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel12}
{null, 5, null, Result: IntLiteralLabel15}
{MULTIPLY(*), 0, 5, Result: VarLocation{name=MULTIPLYLabel17, type=int, expr=0 * 5, size=0}}
{ASSIGN(=), 0 * 5, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel13}
{LABEL, null, null, Result: elseCondLabel12}
{MINUS(-), 0, 0, Result: VarLocation{name=MINUSLabel20, type=int, expr=0 - 0, size=0}}
{ASSIGN(=), 0 - 0, null, Result: VarLocation{name=res, type=float, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel13}
{LABEL, null, null, Result: EndMethod pruAritmetica}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel22}
{null, 8, null, Result: IntLiteralLabel24}
{METHODCALL, pruAritmetica, 2, Result: RESULTLabel26}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[4, 8]}]}, null, Result: EXTERNINVKLabel28}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[]}, null, Result: EXTERNINVKLabel29}
{null, 4, null, Result: IntLiteralLabel30}
{null, 4, null, Result: IntLiteralLabel32}
{METHODCALL, pruAritmetica, 2, Result: RESULTLabel34}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 4}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[4, 4]}]}, null, Result: EXTERNINVKLabel36}
{null, 8, null, Result: IntLiteralLabel37}
{null, 5, null, Result: IntLiteralLabel39}
{METHODCALL, pruAritmetica, 2, Result: RESULTLabel41}
{PARAM, null, null, Result: 8}
{PARAM, null, null, Result: 5}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[8, 5]}]}, null, Result: EXTERNINVKLabel43}
{LABEL, null, null, Result: EndMethod main}



.globl	pruAritmetica
.type	pruAritmetica, @function 
pruAritmetica: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    mov true(%rbp), %eax
    cmp -12(%rbp), %eax

    jne elseCondLabel4

    mov $0, %eax
    mov $0, %edx
    sub %eax, %edx
    mov %edx,-28%(ebp)

    mov 0 - 0(%rbp), %eax
    mov -16(%rbp), %eax

    jmp endIfLabel5

.elseCondLabel4

.endIfLabel5

    movl	$0, %eax
    cmpl	$0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -40(%rbp)

    mov true(%rbp), %eax
    cmp -40(%rbp), %eax

    jne elseCondLabel12

    movl $5, IntLiteralLabel15(%rbp)

    mov $0, %eax
    mov $5, %edx
    imul %edx, %eax
    mov %eax,-56%(ebp)

    mov 0 * 5(%rbp), %eax
    mov -44(%rbp), %eax

    jmp endIfLabel13

.elseCondLabel12

    mov $0, %eax
    mov $0, %edx
    sub %eax, %edx
    mov %edx,-72%(ebp)

    mov 0 - 0(%rbp), %eax
    mov -60(%rbp), %eax

.endIfLabel13

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel22(%rbp)

    movl $8, IntLiteralLabel24(%rbp)

    call pruAritmetica
    movl %eax, RESULTLabel26(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel28(%rbp) 

    call "printf"
    movl %eax, EXTERNINVKLabel29(%rbp) 

    movl $4, IntLiteralLabel30(%rbp)

    movl $4, IntLiteralLabel32(%rbp)

    call pruAritmetica
    movl %eax, RESULTLabel34(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel36(%rbp) 

    movl $8, IntLiteralLabel37(%rbp)

    movl $5, IntLiteralLabel39(%rbp)

    call pruAritmetica
    movl %eax, RESULTLabel41(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel43(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_logicos01.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20
OFFSET = -32
OFFSET = -36
OFFSET = -48
OFFSET = -52
Error: Method pruebaLogica must return int

parseo exitoso
tamaño lista de codigo tercetos: 19
lista: 
{LABEL, null, null, Result: BeginMethod pruebaLogica}

{METHODDECL, Metodo{ name=pruebaLogica, return_not_void=true, typeReturn=int, parameters [Simbolo{type=boolean, name=i, value=null, size=0}]}, null, Result: null}
{null, true, null, Result: BoolLiteralLabel1}
{ASSIGN(=), true, null, Result: VarLocation{name=a, type=boolean, expr=null, size=0}}
{null, false, null, Result: BoolLiteralLabel3}
{OR(||), false, false, Result: VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0}}
{null, true, null, Result: BoolLiteralLabel8}
{NON(!), true, null, Result: VarLocation{name=NONLabel10, type=boolean, expr=!true, size=0}}
{AND(&&), VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0}, !true, Result: VarLocation{name=CONJUNCIONLabel11, type=boolean, expr=VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0} && !true, size=0}}
{NON(!), false, null, Result: VarLocation{name=NONLabel14, type=boolean, expr=!false, size=0}}
{AND(&&), VarLocation{name=CONJUNCIONLabel11, type=boolean, expr=VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0} && !true, size=0}, !false, Result: VarLocation{name=CONJUNCIONLabel15, type=boolean, expr=VarLocation{name=CONJUNCIONLabel11, type=boolean, expr=VarLocation{name=DISYUNCIONLabel6, type=boolean, expr=false || false, size=0} && !true, size=0} && !false, size=0}}
{LABEL, null, null, Result: EndMethod pruebaLogica}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, false, null, Result: BoolLiteralLabel17}
{METHODCALL, pruebaLogica, 1, Result: RESULTLabel19}
{PARAM, null, null, Result: false}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruebaLogica, args=[false]}]}, null, Result: EXTERNINVKLabel21}
{LABEL, null, null, Result: EndMethod main}

{Or}TRATAMIENTO PARA class ir.ast.BoolLiteral y class ir.ast.BoolLiteral PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.VarLocation y class ir.ast.UnaryOpExpr PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.VarLocation y class ir.ast.UnaryOpExpr PENDIENTE


.globl	pruebaLogica
.type	pruebaLogica, @function 
pruebaLogica: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $true, BoolLiteralLabel1(%rbp)

    mov true(%rbp), %eax
    mov -4(%rbp), %eax

    movl $false, BoolLiteralLabel3(%rbp)


    movl $true, BoolLiteralLabel8(%rbp)

    cmp $0, true(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -32(%rbp) 


    cmp $0, false(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -48(%rbp) 


    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $false, BoolLiteralLabel17(%rbp)

    call pruebaLogica
    movl %eax, RESULTLabel19(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel21(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_logicos02.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -28
OFFSET = -36
OFFSET = -48
OFFSET = -60
OFFSET = -72
OFFSET = -88
OFFSET = -96
OFFSET = -108
OFFSET = -120
OFFSET = -132
OFFSET = -148
OFFSET = -156
OFFSET = -168
OFFSET = -180
OFFSET = -192
OFFSET = -208
OFFSET = -216
OFFSET = -228
OFFSET = -236

parseo exitoso
tamaño lista de codigo tercetos: 63
lista: 
{LABEL, null, null, Result: BeginMethod promedio}

{METHODDECL, Metodo{ name=promedio, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=nota1, value=null, size=0}, Simbolo{type=float, name=nota2, value=null, size=0}, Simbolo{type=float, name=nota3, value=null, size=0}]}, null, Result: null}
{GE(>), 0.0, 0.0, Result: VarLocation{name=GELabel3, type=boolean, expr=0.0 > 0.0, size=0}}
{GE(>), 0.0, 0.0, Result: VarLocation{name=GELabel7, type=boolean, expr=0.0 > 0.0, size=0}}
{AND(&&), VarLocation{name=GELabel3, type=boolean, expr=0.0 > 0.0, size=0}, VarLocation{name=GELabel7, type=boolean, expr=0.0 > 0.0, size=0}, Result: VarLocation{name=CONJUNCIONLabel9, type=boolean, expr=VarLocation{name=GELabel3, type=boolean, expr=0.0 > 0.0, size=0} && VarLocation{name=GELabel7, type=boolean, expr=0.0 > 0.0, size=0}, size=0}}
{CMP, VarLocation{name=CONJUNCIONLabel9, type=boolean, expr=VarLocation{name=GELabel3, type=boolean, expr=0.0 > 0.0, size=0} && VarLocation{name=GELabel7, type=boolean, expr=0.0 > 0.0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel10}
{PLUS(+), 0.0, 0.0, Result: VarLocation{name=PLUSLabel14, type=float, expr=0.0 + 0.0, size=0}}
{null, 2.0, null, Result: FloatLiteralLabel16}
{DIVIDE(/), VarLocation{name=PLUSLabel14, type=float, expr=0.0 + 0.0, size=0}, 2.0, Result: VarLocation{name=DIVIDELabel18, type=float, expr=VarLocation{name=factorLabel15, type=float, expr=VarLocation{name=PLUSLabel14, type=float, expr=0.0 + 0.0, size=0}, size=0} / VarLocation{name=factorLabel17, type=float, expr=2.0, size=0}, size=0}}
{RETURN, null, null, Result: VarLocation{name=factorLabel15, type=float, expr=VarLocation{name=PLUSLabel14, type=float, expr=0.0 + 0.0, size=0}, size=0} / VarLocation{name=factorLabel17, type=float, expr=2.0, size=0}}
{JMP, null, null, Result: endIfLabel11}
{LABEL, null, null, Result: elseCondLabel10}
{LABEL, null, null, Result: endIfLabel11}
{GE(>), 0.0, 0.0, Result: VarLocation{name=GELabel21, type=boolean, expr=0.0 > 0.0, size=0}}
{GE(>), 0.0, 0.0, Result: VarLocation{name=GELabel25, type=boolean, expr=0.0 > 0.0, size=0}}
{AND(&&), VarLocation{name=GELabel21, type=boolean, expr=0.0 > 0.0, size=0}, VarLocation{name=GELabel25, type=boolean, expr=0.0 > 0.0, size=0}, Result: VarLocation{name=CONJUNCIONLabel27, type=boolean, expr=VarLocation{name=GELabel21, type=boolean, expr=0.0 > 0.0, size=0} && VarLocation{name=GELabel25, type=boolean, expr=0.0 > 0.0, size=0}, size=0}}
{CMP, VarLocation{name=CONJUNCIONLabel27, type=boolean, expr=VarLocation{name=GELabel21, type=boolean, expr=0.0 > 0.0, size=0} && VarLocation{name=GELabel25, type=boolean, expr=0.0 > 0.0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel28}
{PLUS(+), 0.0, 0.0, Result: VarLocation{name=PLUSLabel32, type=float, expr=0.0 + 0.0, size=0}}
{null, 2.0, null, Result: FloatLiteralLabel34}
{DIVIDE(/), VarLocation{name=PLUSLabel32, type=float, expr=0.0 + 0.0, size=0}, 2.0, Result: VarLocation{name=DIVIDELabel36, type=float, expr=VarLocation{name=factorLabel33, type=float, expr=VarLocation{name=PLUSLabel32, type=float, expr=0.0 + 0.0, size=0}, size=0} / VarLocation{name=factorLabel35, type=float, expr=2.0, size=0}, size=0}}
{RETURN, null, null, Result: VarLocation{name=factorLabel33, type=float, expr=VarLocation{name=PLUSLabel32, type=float, expr=0.0 + 0.0, size=0}, size=0} / VarLocation{name=factorLabel35, type=float, expr=2.0, size=0}}
{JMP, null, null, Result: endIfLabel29}
{LABEL, null, null, Result: elseCondLabel28}
{LABEL, null, null, Result: endIfLabel29}
{GE(>), 0.0, 0.0, Result: VarLocation{name=GELabel39, type=boolean, expr=0.0 > 0.0, size=0}}
{GE(>), 0.0, 0.0, Result: VarLocation{name=GELabel43, type=boolean, expr=0.0 > 0.0, size=0}}
{AND(&&), VarLocation{name=GELabel39, type=boolean, expr=0.0 > 0.0, size=0}, VarLocation{name=GELabel43, type=boolean, expr=0.0 > 0.0, size=0}, Result: VarLocation{name=CONJUNCIONLabel45, type=boolean, expr=VarLocation{name=GELabel39, type=boolean, expr=0.0 > 0.0, size=0} && VarLocation{name=GELabel43, type=boolean, expr=0.0 > 0.0, size=0}, size=0}}
{CMP, VarLocation{name=CONJUNCIONLabel45, type=boolean, expr=VarLocation{name=GELabel39, type=boolean, expr=0.0 > 0.0, size=0} && VarLocation{name=GELabel43, type=boolean, expr=0.0 > 0.0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel46}
{PLUS(+), 0.0, 0.0, Result: VarLocation{name=PLUSLabel50, type=float, expr=0.0 + 0.0, size=0}}
{null, 2.0, null, Result: FloatLiteralLabel52}
{DIVIDE(/), VarLocation{name=PLUSLabel50, type=float, expr=0.0 + 0.0, size=0}, 2.0, Result: VarLocation{name=DIVIDELabel54, type=float, expr=VarLocation{name=factorLabel51, type=float, expr=VarLocation{name=PLUSLabel50, type=float, expr=0.0 + 0.0, size=0}, size=0} / VarLocation{name=factorLabel53, type=float, expr=2.0, size=0}, size=0}}
{RETURN, null, null, Result: VarLocation{name=factorLabel51, type=float, expr=VarLocation{name=PLUSLabel50, type=float, expr=0.0 + 0.0, size=0}, size=0} / VarLocation{name=factorLabel53, type=float, expr=2.0, size=0}}
{JMP, null, null, Result: endIfLabel47}
{LABEL, null, null, Result: elseCondLabel46}
{LABEL, null, null, Result: endIfLabel47}
{CEQ(==), 0.0, 0.0, Result: VarLocation{name=CEQLabel57, type=boolean, expr=0.0 == 0.0, size=0}}
{CEQ(==), 0.0, 0.0, Result: VarLocation{name=CEQLabel61, type=boolean, expr=0.0 == 0.0, size=0}}
{AND(&&), VarLocation{name=CEQLabel57, type=boolean, expr=0.0 == 0.0, size=0}, VarLocation{name=CEQLabel61, type=boolean, expr=0.0 == 0.0, size=0}, Result: VarLocation{name=CONJUNCIONLabel63, type=boolean, expr=VarLocation{name=CEQLabel57, type=boolean, expr=0.0 == 0.0, size=0} && VarLocation{name=CEQLabel61, type=boolean, expr=0.0 == 0.0, size=0}, size=0}}
{CEQ(==), 0.0, 0.0, Result: VarLocation{name=CEQLabel66, type=boolean, expr=0.0 == 0.0, size=0}}
{AND(&&), VarLocation{name=CEQLabel57, type=boolean, expr=0.0 == 0.0, size=0} && VarLocation{name=CEQLabel61, type=boolean, expr=0.0 == 0.0, size=0}, VarLocation{name=CEQLabel66, type=boolean, expr=0.0 == 0.0, size=0}, Result: VarLocation{name=CONJUNCIONLabel68, type=boolean, expr=VarLocation{name=CEQLabel57, type=boolean, expr=0.0 == 0.0, size=0} && VarLocation{name=CEQLabel61, type=boolean, expr=0.0 == 0.0, size=0} && VarLocation{name=CEQLabel66, type=boolean, expr=0.0 == 0.0, size=0}, size=0}}
{CMP, VarLocation{name=CONJUNCIONLabel68, type=boolean, expr=VarLocation{name=CEQLabel57, type=boolean, expr=0.0 == 0.0, size=0} && VarLocation{name=CEQLabel61, type=boolean, expr=0.0 == 0.0, size=0} && VarLocation{name=CEQLabel66, type=boolean, expr=0.0 == 0.0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel69}
{RETURN, null, null, Result: 0.0}
{JMP, null, null, Result: endIfLabel70}
{LABEL, null, null, Result: elseCondLabel69}
{LABEL, null, null, Result: endIfLabel70}
{LABEL, null, null, Result: EndMethod promedio}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 3.3, null, Result: FloatLiteralLabel72}
{null, 0.66, null, Result: FloatLiteralLabel74}
{null, 10.0, null, Result: FloatLiteralLabel76}
{METHODCALL, promedio, 3, Result: RESULTLabel78}
{PARAM, null, null, Result: 3.3}
{PARAM, null, null, Result: 0.66}
{PARAM, null, null, Result: 10.0}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[StringLiteral{value="%f resultado : "}, MethodCallExpr{name=promedio, args=[3.3, 0.66, 10.0]}]}, null, Result: EXTERNINVKLabel80}
{null, 1, null, Result: IntLiteralLabel81}
{RETURN, null, null, Result: 1}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE
{And}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.VarLocation PENDIENTE


.globl	promedio
.type	promedio, @function 
promedio: 
    enter   $(12), $0 
    push	%rbp
    mov %rsp, %rbp

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -28(%rbp)

    cmp	$0, -12(%rbp)
    je .L0
    cmp	$0, -28(%rbp)
    je .L0
    mov	$1, %eax
    jmp .L1
.L0:
    movl	$0, %eax
    jmp .L2
.L1:
    movl	%eax, -36(%rbp)
.L2:

    mov true(%rbp), %eax
    cmp -36(%rbp), %eax

    jne elseCondLabel10


    movl $2.0, FloatLiteralLabel16(%rbp)

DIVIDE(/)

    mov VarLocation{name=factorLabel15, type=float, expr=VarLocation{name=PLUSLabel14, type=float, expr=0.0 + 0.0, size=0}, size=0} / VarLocation{name=factorLabel17, type=float, expr=2.0, size=0}(%rbp), %eax

    jmp endIfLabel11

.elseCondLabel10

.endIfLabel11

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -72(%rbp)

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -88(%rbp)

    cmp	$0, -72(%rbp)
    je .L3
    cmp	$0, -88(%rbp)
    je .L3
    mov	$1, %eax
    jmp .L4
.L3:
    movl	$0, %eax
    jmp .L5
.L4:
    movl	%eax, -96(%rbp)
.L5:

    mov true(%rbp), %eax
    cmp -96(%rbp), %eax

    jne elseCondLabel28


    movl $2.0, FloatLiteralLabel34(%rbp)

DIVIDE(/)

    mov VarLocation{name=factorLabel33, type=float, expr=VarLocation{name=PLUSLabel32, type=float, expr=0.0 + 0.0, size=0}, size=0} / VarLocation{name=factorLabel35, type=float, expr=2.0, size=0}(%rbp), %eax

    jmp endIfLabel29

.elseCondLabel28

.endIfLabel29

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -132(%rbp)

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -148(%rbp)

    cmp	$0, -132(%rbp)
    je .L6
    cmp	$0, -148(%rbp)
    je .L6
    mov	$1, %eax
    jmp .L7
.L6:
    movl	$0, %eax
    jmp .L8
.L7:
    movl	%eax, -156(%rbp)
.L8:

    mov true(%rbp), %eax
    cmp -156(%rbp), %eax

    jne elseCondLabel46


    movl $2.0, FloatLiteralLabel52(%rbp)

DIVIDE(/)

    mov VarLocation{name=factorLabel51, type=float, expr=VarLocation{name=PLUSLabel50, type=float, expr=0.0 + 0.0, size=0}, size=0} / VarLocation{name=factorLabel53, type=float, expr=2.0, size=0}(%rbp), %eax

    jmp endIfLabel47

.elseCondLabel46

.endIfLabel47

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -192(%rbp)

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -208(%rbp)

    cmp	$0, -192(%rbp)
    je .L9
    cmp	$0, -208(%rbp)
    je .L9
    mov	$1, %eax
    jmp .L10
.L9:
    movl	$0, %eax
    jmp .L11
.L10:
    movl	%eax, -216(%rbp)
.L11:

    movl	$0.0, %eax
    cmpl	$0.0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -228(%rbp)


    mov true(%rbp), %eax
    cmp -236(%rbp), %eax

    jne elseCondLabel69

    mov 0.0(%rbp), %eax

    jmp endIfLabel70

.elseCondLabel69

.endIfLabel70

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $3.3, FloatLiteralLabel72(%rbp)

    movl $0.66, FloatLiteralLabel74(%rbp)

    movl $10.0, FloatLiteralLabel76(%rbp)

    call promedio
    movl %eax, RESULTLabel78(%rbp) 

PARAM

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel80(%rbp) 

    movl $1, IntLiteralLabel81(%rbp)

    mov 1(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_mainSolo.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -24
OFFSET = -36
OFFSET = -48
OFFSET = -52

parseo exitoso
tamaño lista de codigo tercetos: 12
lista: 
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{null, true, null, Result: BoolLiteralLabel1}
{ASSIGN(=), true, null, Result: VarLocation{name=a, type=boolean, expr=null, size=0}}
{NON(!), false, null, Result: VarLocation{name=NONLabel4, type=boolean, expr=!false, size=0}}
{ASSIGN(=), !false, null, Result: VarLocation{name=b, type=boolean, expr=null, size=0}}
{AND(&&), false, false, Result: VarLocation{name=CONJUNCIONLabel7, type=boolean, expr=false && false, size=0}}
{NON(!), false, null, Result: VarLocation{name=NONLabel10, type=boolean, expr=!false, size=0}}
{OR(||), VarLocation{name=CONJUNCIONLabel7, type=boolean, expr=false && false, size=0}, !false, Result: VarLocation{name=DISYUNCIONLabel11, type=boolean, expr=VarLocation{name=CONJUNCIONLabel7, type=boolean, expr=false && false, size=0} || !false, size=0}}
{ASSIGN(=), VarLocation{name=CONJUNCIONLabel7, type=boolean, expr=false && false, size=0} || !false, null, Result: VarLocation{name=c, type=boolean, expr=null, size=0}}
{EXTERNINVK, ExternInvkExpr{id="printf", type=boolean, parameters=[false]}, null, Result: EXTERNINVKLabel13}
{LABEL, null, null, Result: EndMethod main}

{And}TRATAMIENTO PARA class ir.ast.BoolLiteral y class ir.ast.BoolLiteral PENDIENTE
{Or}TRATAMIENTO PARA class ir.ast.VarLocation y class ir.ast.UnaryOpExpr PENDIENTE


.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $true, BoolLiteralLabel1(%rbp)

    mov true(%rbp), %eax
    mov -4(%rbp), %eax

    cmp $0, false(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -20(%rbp) 

    mov !false(%rbp), %eax
    mov -12(%rbp), %eax


    cmp $0, false(%rbp) 
    sete	%al 
    movzbl %al, %eax 
    mov %eax, -48(%rbp) 


    mov VarLocation{name=CONJUNCIONLabel7, type=boolean, expr=false && false, size=0} || !false(%rbp), %eax
    mov -24(%rbp), %eax

    call "printf"
    movl %eax, EXTERNINVKLabel13(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_mcd.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -16
OFFSET = -24
OFFSET = -32
OFFSET = -40
OFFSET = -48
OFFSET = -64
OFFSET = -76
OFFSET = -88
OFFSET = -92
OFFSET = -100

parseo exitoso
tamaño lista de codigo tercetos: 36
lista: 
{LABEL, null, null, Result: BeginMethod maxcomdiv}

{METHODDECL, Metodo{ name=maxcomdiv, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=a, value=null, size=0}, Simbolo{type=int, name=b, value=null, size=0}]}, null, Result: null}
{GE(>), 0, 0, Result: VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}}
{CMP, VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel4}
{ASSIGN(=), 0, null, Result: VarLocation{name=dividendo, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=divisor, type=int, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: elseCondLabel4}
{ASSIGN(=), 0, null, Result: VarLocation{name=dividendo, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=divisor, type=int, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel5}
{null, 1, null, Result: IntLiteralLabel10}
{ASSIGN(=), 1, null, Result: VarLocation{name=resto, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel13}
{NEQ(!=), 0, 0, Result: VarLocation{name=NEQLabel15, type=boolean, expr=0 != 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel18}
{CMP, VarLocation{name=factorLabel17, type=boolean, expr=VarLocation{name=factorLabel16, type=boolean, expr=VarLocation{name=NEQLabel15, type=boolean, expr=0 != 0, size=0}, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel19}
{MOD(%), 0, 0, Result: VarLocation{name=MODLabel22, type=int, expr=0 % 0, size=0}}
{ASSIGN(=), 0 % 0, null, Result: VarLocation{name=resto, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=dividendo, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=divisor, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel18}
{LABEL, null, null, Result: EndWhileLabel19}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod maxcomdiv}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 6, null, Result: IntLiteralLabel26}
{null, 9, null, Result: IntLiteralLabel28}
{METHODCALL, maxcomdiv, 2, Result: RESULTLabel30}
{PARAM, null, null, Result: 6}
{PARAM, null, null, Result: 9}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[StringLiteral{value="mcd%d"}, MethodCallExpr{name=maxcomdiv, args=[6, 9]}]}, null, Result: EXTERNINVKLabel32}
{LABEL, null, null, Result: EndMethod main}



.globl	maxcomdiv
.type	maxcomdiv, @function 
maxcomdiv: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    mov true(%rbp), %eax
    cmp -12(%rbp), %eax

    jne elseCondLabel4

    mov 0(%rbp), %eax
    mov -16(%rbp), %eax

    mov 0(%rbp), %eax
    mov -24(%rbp), %eax

    jmp endIfLabel5

.elseCondLabel4

    mov 0(%rbp), %eax
    mov -32(%rbp), %eax

    mov 0(%rbp), %eax
    mov -40(%rbp), %eax

.endIfLabel5

    movl $1, IntLiteralLabel10(%rbp)

    mov 1(%rbp), %eax
    mov -48(%rbp), %eax

    movl $0, IntLiteralLabel13(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setgne %al
    movzbl %al, %eax
    movl	%eax, -64(%rbp)

.BeginWhileLabel18

    mov true(%rbp), %eax
    cmp -72(%rbp), %eax

    jne EndWhileLabel19

    movl	$0, %eax 
    idivl $0, %eax 
    movl	%edx, -88(%rbp)

    mov 0 % 0(%rbp), %eax
    mov -76(%rbp), %eax

    mov 0(%rbp), %eax
    mov -92(%rbp), %eax

    mov 0(%rbp), %eax
    mov -100(%rbp), %eax

    jmp BeginWhileLabel18

.EndWhileLabel19

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $6, IntLiteralLabel26(%rbp)

    movl $9, IntLiteralLabel28(%rbp)

    call maxcomdiv
    movl %eax, RESULTLabel30(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel32(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_metodos00.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -16
Error: Method alo not declared
OFFSET = -4
Error: Method alo not declared
ocurrio un error: null
---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_metodos01.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -16
OFFSET = -8
OFFSET = -20
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -32
OFFSET = -48
Error: Method alo2 not declared
ocurrio un error: null
---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_metodos02.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -20
OFFSET = -24
OFFSET = -36
OFFSET = -12
OFFSET = -24
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -48
Error: Method alo not declared

parseo exitoso
tamaño lista de codigo tercetos: 41
lista: 
{LABEL, null, null, Result: BeginMethod alo}

{METHODDECL, Metodo{ name=alo, return_not_void=false, typeReturn=void, parameters [Simbolo{type=boolean, name=b, value=null, size=0}, Simbolo{type=int, name=x, value=null, size=0}]}, null, Result: null}
{CMP, VarLocation{name=factorLabel1, type=boolean, expr=false, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel2}
{null, 1, null, Result: IntLiteralLabel5}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel7, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=x, type=int, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel3}
{LABEL, null, null, Result: elseCondLabel2}
{null, 1, null, Result: IntLiteralLabel9}
{MINUS(-), 0, 1, Result: VarLocation{name=MINUSLabel11, type=int, expr=0 - 1, size=0}}
{ASSIGN(=), 0 - 1, null, Result: VarLocation{name=x, type=int, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel3}
{LABEL, null, null, Result: EndMethod alo}
{LABEL, null, null, Result: BeginMethod Alo}

{METHODDECL, Metodo{ name=Alo, return_not_void=false, typeReturn=void, parameters [Simbolo{type=boolean, name=b, value=null, size=0}, Simbolo{type=int, name=x, value=null, size=0}]}, null, Result: null}
{LABEL, null, null, Result: EndMethod Alo}
{LABEL, null, null, Result: BeginMethod alo2}

{METHODDECL, Metodo{ name=alo2, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=x, value=null, size=0}]}, null, Result: null}
{null, true, null, Result: BoolLiteralLabel12}
{METHODCALL, alo, 2, Result: RESULTLabel15}
{PARAM, null, null, Result: true}
{PARAM, null, null, Result: 0}
{null, 1, null, Result: IntLiteralLabel17}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel19, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=x, type=int, expr=null, size=0}}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod alo2}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=false, typeReturn=void, parameters []}, null, Result: null}
{null, 7, null, Result: IntLiteralLabel21}
{ASSIGN(=), 7, null, Result: VarLocation{name=y, type=int, expr=null, size=0}}
{null, 8.0, null, Result: FloatLiteralLabel23}
{ASSIGN(=), 8.0, null, Result: VarLocation{name=c, type=float, expr=null, size=0}}
{METHODCALL, alo2, 1, Result: RESULTLabel26}
{PARAM, null, null, Result: 0}
{ASSIGN(=), MethodCallExpr{name=alo2, args=[0]}, null, Result: VarLocation{name=y, type=int, expr=null, size=0}}
{null, false, null, Result: BoolLiteralLabel28}
{null, 3, null, Result: IntLiteralLabel30}
{MULTIPLY(*), VarLocation{name=factorLabel31, type=int, expr=3, size=0}, 0, Result: VarLocation{name=MULTIPLYLabel34, type=int, expr=VarLocation{name=factorLabel31, type=int, expr=3, size=0} * 0, size=0}}
{LABEL, null, null, Result: EndMethod main}



.globl	alo
.type	alo, @function 
alo: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    mov true(%rbp), %eax
    cmp -4(%rbp), %eax

    jne elseCondLabel2

    movl $1, IntLiteralLabel5(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-20%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -8(%rbp), %eax

    jmp endIfLabel3

.elseCondLabel2

    movl $1, IntLiteralLabel9(%rbp)

    mov $0, %eax
    mov $1, %edx
    sub %eax, %edx
    mov %edx,-36%(ebp)

    mov 0 - 1(%rbp), %eax
    mov -24(%rbp), %eax

.endIfLabel3

    leave
    ret



.globl	Alo
.type	Alo, @function 
Alo: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    leave
    ret



.globl	alo2
.type	alo2, @function 
alo2: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $true, BoolLiteralLabel12(%rbp)

    call alo
    movl %eax, RESULTLabel15(%rbp) 

PARAM

PARAM

    movl $1, IntLiteralLabel17(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-24%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -12(%rbp), %eax

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $7, IntLiteralLabel21(%rbp)

    mov 7(%rbp), %eax
    mov -4(%rbp), %eax

    movl $8.0, FloatLiteralLabel23(%rbp)

    mov 8.0(%rbp), %eax
    mov -12(%rbp), %eax

    call alo2
    movl %eax, RESULTLabel26(%rbp) 

PARAM

    mov MethodCallExpr{name=alo2, args=[0]}(%rbp), %eax
    mov -20(%rbp), %eax

    movl $false, BoolLiteralLabel28(%rbp)

    movl $3, IntLiteralLabel30(%rbp)

    mov -36(%ebp) , %eax 
    mov $0, %edx
    imul %edx, %eax 
    mov %eax,-48%(ebp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_metodos03.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -16
OFFSET = -20
OFFSET = -24
OFFSET = -36
OFFSET = -40
OFFSET = -52
OFFSET = -4
OFFSET = -16

parseo exitoso
tamaño lista de codigo tercetos: 39
lista: 
{LABEL, null, null, Result: BeginMethod inc}

{METHODDECL, Metodo{ name=inc, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=x, value=null, size=0}]}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel2}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel4, type=int, expr=0 + 1, size=0}}
{RETURN, null, null, Result: 0 + 1}
{LABEL, null, null, Result: EndMethod inc}
{LABEL, null, null, Result: BeginMethod resto}

{METHODDECL, Metodo{ name=resto, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=x, value=null, size=0}, Simbolo{type=float, name=y, value=null, size=0}]}, null, Result: null}
{null, 3, null, Result: IntLiteralLabel6}
{null, 2, null, Result: IntLiteralLabel8}
{MULTIPLY(*), 3, 2, Result: VarLocation{name=MULTIPLYLabel10, type=int, expr=3 * 2, size=0}}
{GE(>), 0, 3 * 2, Result: VarLocation{name=GELabel11, type=boolean, expr=0 > 3 * 2, size=0}}
{CMP, VarLocation{name=GELabel11, type=boolean, expr=0 > 3 * 2, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel12}
{null, 3, null, Result: IntLiteralLabel15}
{DIVIDE(/), 0, 3, Result: VarLocation{name=DIVIDELabel17, type=int, expr=0 / 3, size=0}}
{ASSIGN(=), 0 / 3, null, Result: VarLocation{name=res, type=int, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel13}
{LABEL, null, null, Result: elseCondLabel12}
{null, 2, null, Result: IntLiteralLabel19}
{MOD(%), 0, 2, Result: VarLocation{name=MODLabel21, type=int, expr=0 % 2, size=0}}
{ASSIGN(=), 0 % 2, null, Result: VarLocation{name=res, type=int, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel13}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod resto}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, false, null, Result: BoolLiteralLabel23}
{ASSIGN(=), false, null, Result: VarLocation{name=res, type=boolean, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel25}
{null, 5, null, Result: IntLiteralLabel27}
{METHODCALL, inc, 1, Result: RESULTLabel29}
{PARAM, null, null, Result: 5}
{null, 10.2, null, Result: FloatLiteralLabel31}
{METHODCALL, resto, 2, Result: RESULTLabel33}
{PARAM, null, null, Result: MethodCallExpr{name=inc, args=[5]}}
{PARAM, null, null, Result: 10.2}
{ASSIGN(=), MethodCallExpr{name=resto, args=[MethodCallExpr{name=inc, args=[5]}, 10.2]}, null, Result: VarLocation{name=A, type=int[], expr=null, size=1}}
{LABEL, null, null, Result: EndMethod main}

{logic} FALTA CASO (2do param)class ir.ast.BinOpExpr


.globl	inc
.type	inc, @function 
inc: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel2(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-12%(ebp) 

    mov 0 + 1(%rbp), %eax

    leave
    ret



.globl	resto
.type	resto, @function 
resto: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $3, IntLiteralLabel6(%rbp)

    movl $2, IntLiteralLabel8(%rbp)

    mov $3, %eax
    mov $2, %edx
    imul %edx, %eax
    mov %eax,-16%(ebp)

    movl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -20(%rbp)

    mov true(%rbp), %eax
    cmp -20(%rbp), %eax

    jne elseCondLabel12

    movl $3, IntLiteralLabel15(%rbp)

DIVIDE(/)

    mov 0 / 3(%rbp), %eax
    mov -24(%rbp), %eax

    jmp endIfLabel13

.elseCondLabel12

    movl $2, IntLiteralLabel19(%rbp)

    movl	$2, %eax 
    idivl $0, %eax 
    movl	%edx, -52(%rbp)

    mov 0 % 2(%rbp), %eax
    mov -40(%rbp), %eax

.endIfLabel13

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $false, BoolLiteralLabel23(%rbp)

    mov false(%rbp), %eax
    mov -4(%rbp), %eax

    movl $0, IntLiteralLabel25(%rbp)

    movl $5, IntLiteralLabel27(%rbp)

    call inc
    movl %eax, RESULTLabel29(%rbp) 

PARAM

    movl $10.2, FloatLiteralLabel31(%rbp)

    call resto
    movl %eax, RESULTLabel33(%rbp) 

PARAM

PARAM

    mov MethodCallExpr{name=resto, args=[MethodCallExpr{name=inc, args=[5]}, 10.2]}(%rbp), %eax
    mov -16(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_metodos_externos01.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -16
Error: Method alo not declared
OFFSET = -4
Error: Method alo not declared
ocurrio un error: null
---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_metodos_externos02.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -16
OFFSET = -24
OFFSET = -32
OFFSET = -40
OFFSET = -48
OFFSET = -64
OFFSET = -76
OFFSET = -88
OFFSET = -92
OFFSET = -100
OFFSET = -4
OFFSET = -32
OFFSET = -44
OFFSET = -48

parseo exitoso
tamaño lista de codigo tercetos: 44
lista: 
{LABEL, null, null, Result: BeginMethod maxcomdiv}

{METHODDECL, Metodo{ name=maxcomdiv, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=a, value=null, size=0}, Simbolo{type=int, name=b, value=null, size=0}]}, null, Result: null}
{GE(>), 0, 0, Result: VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}}
{CMP, VarLocation{name=GELabel3, type=boolean, expr=0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel4}
{ASSIGN(=), 0, null, Result: VarLocation{name=dividendo, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=divisor, type=int, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel5}
{LABEL, null, null, Result: elseCondLabel4}
{ASSIGN(=), 0, null, Result: VarLocation{name=dividendo, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=divisor, type=int, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel5}
{null, 1, null, Result: IntLiteralLabel10}
{ASSIGN(=), 1, null, Result: VarLocation{name=resto, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel13}
{NEQ(!=), 0, 0, Result: VarLocation{name=NEQLabel15, type=boolean, expr=0 != 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel18}
{CMP, VarLocation{name=factorLabel17, type=boolean, expr=VarLocation{name=factorLabel16, type=boolean, expr=VarLocation{name=NEQLabel15, type=boolean, expr=0 != 0, size=0}, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel19}
{MOD(%), 0, 0, Result: VarLocation{name=MODLabel22, type=int, expr=0 % 0, size=0}}
{ASSIGN(=), 0 % 0, null, Result: VarLocation{name=resto, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=dividendo, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=divisor, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel18}
{LABEL, null, null, Result: EndWhileLabel19}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod maxcomdiv}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 10000, null, Result: IntLiteralLabel26}
{ASSIGN(=), 10000, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 6, null, Result: IntLiteralLabel28}
{null, 9, null, Result: IntLiteralLabel30}
{METHODCALL, maxcomdiv, 2, Result: RESULTLabel32}
{PARAM, null, null, Result: 6}
{PARAM, null, null, Result: 9}
{null, 3.5, null, Result: FloatLiteralLabel34}
{MULTIPLY(*), 3.5, 0, Result: VarLocation{name=MULTIPLYLabel37, type=int, expr=3.5 * 0, size=0}}
{null, 7, null, Result: IntLiteralLabel38}
{null, 6, null, Result: IntLiteralLabel40}
{DIVIDE(/), 7, 6, Result: VarLocation{name=DIVIDELabel42, type=int, expr=7 / 6, size=0}}
{MINUS(-), 3.5 * 0, 7 / 6, Result: VarLocation{name=MINUSLabel43, type=int, expr=3.5 * 0 - 7 / 6, size=0}}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[StringLiteral{value="%d%f"}, StringLiteral{value="mcd"}, MethodCallExpr{name=maxcomdiv, args=[6, 9]}, 3.5 * 0 - 7 / 6]}, null, Result: EXTERNINVKLabel44}
{LABEL, null, null, Result: EndMethod main}

{Imul}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.IntLiteral PENDIENTE
{Add}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.BinOpExpr PENDIENTE


.globl	maxcomdiv
.type	maxcomdiv, @function 
maxcomdiv: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    mov true(%rbp), %eax
    cmp -12(%rbp), %eax

    jne elseCondLabel4

    mov 0(%rbp), %eax
    mov -16(%rbp), %eax

    mov 0(%rbp), %eax
    mov -24(%rbp), %eax

    jmp endIfLabel5

.elseCondLabel4

    mov 0(%rbp), %eax
    mov -32(%rbp), %eax

    mov 0(%rbp), %eax
    mov -40(%rbp), %eax

.endIfLabel5

    movl $1, IntLiteralLabel10(%rbp)

    mov 1(%rbp), %eax
    mov -48(%rbp), %eax

    movl $0, IntLiteralLabel13(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setgne %al
    movzbl %al, %eax
    movl	%eax, -64(%rbp)

.BeginWhileLabel18

    mov true(%rbp), %eax
    cmp -72(%rbp), %eax

    jne EndWhileLabel19

    movl	$0, %eax 
    idivl $0, %eax 
    movl	%edx, -88(%rbp)

    mov 0 % 0(%rbp), %eax
    mov -76(%rbp), %eax

    mov 0(%rbp), %eax
    mov -92(%rbp), %eax

    mov 0(%rbp), %eax
    mov -100(%rbp), %eax

    jmp BeginWhileLabel18

.EndWhileLabel19

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $10000, IntLiteralLabel26(%rbp)

    mov 10000(%rbp), %eax
    mov -4(%rbp), %eax

    movl $6, IntLiteralLabel28(%rbp)

    movl $9, IntLiteralLabel30(%rbp)

    call maxcomdiv
    movl %eax, RESULTLabel32(%rbp) 

PARAM

PARAM

    movl $3.5, FloatLiteralLabel34(%rbp)


    movl $7, IntLiteralLabel38(%rbp)

    movl $6, IntLiteralLabel40(%rbp)

DIVIDE(/)


    call "printf"
    movl %eax, EXTERNINVKLabel44(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_mod.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20

parseo exitoso
tamaño lista de codigo tercetos: 13
lista: 
{LABEL, null, null, Result: BeginMethod pruAritmetica}

{METHODDECL, Metodo{ name=pruAritmetica, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 90, null, Result: IntLiteralLabel1}
{ASSIGN(=), 90, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 7, null, Result: IntLiteralLabel4}
{MOD(%), 0, 7, Result: VarLocation{name=MODLabel6, type=int, expr=0 % 7, size=0}}
{RETURN, null, null, Result: VarLocation{name=MODLabel6, type=int, expr=0 % 7, size=0}}
{LABEL, null, null, Result: EndMethod pruAritmetica}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{METHODCALL, pruAritmetica, 0, Result: RESULTLabel8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruAritmetica, args=[]}]}, null, Result: EXTERNINVKLabel10}
{LABEL, null, null, Result: EndMethod main}



.globl	pruAritmetica
.type	pruAritmetica, @function 
pruAritmetica: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $90, IntLiteralLabel1(%rbp)

    mov 90(%rbp), %eax
    mov -4(%rbp), %eax

    movl $7, IntLiteralLabel4(%rbp)

    movl	$7, %eax 
    idivl $0, %eax 
    movl	%edx, -20(%rbp)

    mov VarLocation{name=MODLabel6, type=int, expr=0 % 7, size=0}(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    call pruAritmetica
    movl %eax, RESULTLabel8(%rbp) 

    call "printf"
    movl %eax, EXTERNINVKLabel10(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_mult01.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -28
OFFSET = -36
OFFSET = -44

parseo exitoso
tamaño lista de codigo tercetos: 19
lista: 
{LABEL, null, null, Result: BeginMethod pruMult}

{METHODDECL, Metodo{ name=pruMult, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=c, value=null, size=0}]}, null, Result: null}
{null, 5, null, Result: IntLiteralLabel1}
{ASSIGN(=), 5, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 2000, null, Result: IntLiteralLabel3}
{ASSIGN(=), 2000, null, Result: VarLocation{name=d, type=int, expr=null, size=0}}
{null, 1000, null, Result: IntLiteralLabel6}
{MULTIPLY(*), 0, 1000, Result: VarLocation{name=MULTIPLYLabel8, type=int, expr=0 * 1000, size=0}}
{MULTIPLY(*), 0 * 1000, 0, Result: VarLocation{name=MULTIPLYLabel10, type=int, expr=0 * 1000 * 0, size=0}}
{MULTIPLY(*), 0 * 1000 * 0, 0, Result: VarLocation{name=MULTIPLYLabel12, type=int, expr=0 * 1000 * 0 * 0, size=0}}
{RETURN, null, null, Result: VarLocation{name=MULTIPLYLabel12, type=int, expr=0 * 1000 * 0 * 0, size=0}}
{LABEL, null, null, Result: EndMethod pruMult}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 2, null, Result: IntLiteralLabel14}
{METHODCALL, pruMult, 1, Result: RESULTLabel16}
{PARAM, null, null, Result: 2}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruMult, args=[2]}]}, null, Result: EXTERNINVKLabel18}
{LABEL, null, null, Result: EndMethod main}

{Imul}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.IntLiteral PENDIENTE
{Imul}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.IntLiteral PENDIENTE


.globl	pruMult
.type	pruMult, @function 
pruMult: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $5, IntLiteralLabel1(%rbp)

    mov 5(%rbp), %eax
    mov -4(%rbp), %eax

    movl $2000, IntLiteralLabel3(%rbp)

    mov 2000(%rbp), %eax
    mov -12(%rbp), %eax

    movl $1000, IntLiteralLabel6(%rbp)

    mov $0, %eax
    mov $1000, %edx
    imul %edx, %eax
    mov %eax,-28%(ebp)



    mov VarLocation{name=MULTIPLYLabel12, type=int, expr=0 * 1000 * 0 * 0, size=0}(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $2, IntLiteralLabel14(%rbp)

    call pruMult
    movl %eax, RESULTLabel16(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel18(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_mult02.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20

parseo exitoso
tamaño lista de codigo tercetos: 13
lista: 
{LABEL, null, null, Result: BeginMethod pruMult}

{METHODDECL, Metodo{ name=pruMult, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 5, null, Result: IntLiteralLabel1}
{ASSIGN(=), 5, null, Result: VarLocation{name=a, type=int, expr=null, size=0}}
{null, 7, null, Result: IntLiteralLabel4}
{MULTIPLY(*), 0, 7, Result: VarLocation{name=MULTIPLYLabel6, type=int, expr=0 * 7, size=0}}
{RETURN, null, null, Result: VarLocation{name=MULTIPLYLabel6, type=int, expr=0 * 7, size=0}}
{LABEL, null, null, Result: EndMethod pruMult}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{METHODCALL, pruMult, 0, Result: RESULTLabel8}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=pruMult, args=[]}]}, null, Result: EXTERNINVKLabel10}
{LABEL, null, null, Result: EndMethod main}



.globl	pruMult
.type	pruMult, @function 
pruMult: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $5, IntLiteralLabel1(%rbp)

    mov 5(%rbp), %eax
    mov -4(%rbp), %eax

    movl $7, IntLiteralLabel4(%rbp)

    mov $0, %eax
    mov $7, %edx
    imul %edx, %eax
    mov %eax,-20%(ebp)

    mov VarLocation{name=MULTIPLYLabel6, type=int, expr=0 * 7, size=0}(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    call pruMult
    movl %eax, RESULTLabel8(%rbp) 

    call "printf"
    movl %eax, EXTERNINVKLabel10(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_prog_simple.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -16

Error: Main Method Missing in Class prueba2
parseo exitoso
tamaño lista de codigo tercetos: 6
lista: 
{LABEL, null, null, Result: BeginMethod alo}

{METHODDECL, Metodo{ name=alo, return_not_void=false, typeReturn=void, parameters [Simbolo{type=int, name=x, value=null, size=0}]}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel2}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel4, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=x, type=int, expr=null, size=0}}
{LABEL, null, null, Result: EndMethod alo}



.globl	alo
.type	alo, @function 
alo: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel2(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-16%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -4(%rbp), %eax

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_retorno.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -36
OFFSET = -44
OFFSET = -60
OFFSET = -76
OFFSET = -84
OFFSET = -100
OFFSET = -104
OFFSET = -116
OFFSET = -120
OFFSET = -132
OFFSET = -144
OFFSET = -160
OFFSET = -168
OFFSET = -184
OFFSET = -188
OFFSET = -200
OFFSET = -212
OFFSET = -216
OFFSET = -228
OFFSET = -240
OFFSET = -252
OFFSET = -256
OFFSET = -264
OFFSET = -268
OFFSET = -276
OFFSET = -288

parseo exitoso
tamaño lista de codigo tercetos: 80
lista: 
{LABEL, null, null, Result: BeginMethod id}

{METHODDECL, Metodo{ name=id, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=x, value=null, size=0}]}, null, Result: null}
{null, 100, null, Result: IntLiteralLabel1}
{ASSIGN(=), 100, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel3}
{ASSIGN(=), 0, null, Result: VarLocation{name=j, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=z, type=int, expr=null, size=0}}
{LE(<), 0, 0, Result: VarLocation{name=LELabel8, type=boolean, expr=0 < 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel10}
{CMP, VarLocation{name=factorLabel9, type=boolean, expr=VarLocation{name=LELabel8, type=boolean, expr=0 < 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel11}
{ASSIGN(=), 0, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel14}
{GE(>), 0, 0, Result: VarLocation{name=GELabel16, type=boolean, expr=0 > 0, size=0}}
{null, 0, null, Result: IntLiteralLabel19}
{LE(<), 0, 0, Result: VarLocation{name=LELabel21, type=boolean, expr=0 < 0, size=0}}
{OR(||), VarLocation{name=GELabel16, type=boolean, expr=0 > 0, size=0}, VarLocation{name=LELabel21, type=boolean, expr=0 < 0, size=0}, Result: VarLocation{name=DISYUNCIONLabel23, type=boolean, expr=VarLocation{name=GELabel16, type=boolean, expr=0 > 0, size=0} || VarLocation{name=LELabel21, type=boolean, expr=0 < 0, size=0}, size=0}}
{LABEL, null, null, Result: BeginWhileLabel25}
{CMP, VarLocation{name=factorLabel24, type=boolean, expr=VarLocation{name=DISYUNCIONLabel23, type=boolean, expr=VarLocation{name=GELabel16, type=boolean, expr=0 > 0, size=0} || VarLocation{name=LELabel21, type=boolean, expr=0 < 0, size=0}, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel26}
{null, 0, null, Result: IntLiteralLabel28}
{GE(>), 0, 0, Result: VarLocation{name=GELabel30, type=boolean, expr=0 > 0, size=0}}
{CMP, VarLocation{name=GELabel30, type=boolean, expr=0 > 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel31}
{null, 1, null, Result: IntLiteralLabel34}
{MINUS(-), 0, 1, Result: VarLocation{name=MINUSLabel36, type=int, expr=0 - 1, size=0}}
{ASSIGN(=), 0 - 1, null, Result: VarLocation{name=x, type=int, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel32}
{LABEL, null, null, Result: elseCondLabel31}
{null, 1, null, Result: IntLiteralLabel38}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel40, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=x, type=int, expr=null, size=0}}
{LABEL, null, null, Result: endIfLabel32}
{JMP, null, null, Result: BeginWhileLabel25}
{LABEL, null, null, Result: EndWhileLabel26}
{LE(<), 0, 0, Result: VarLocation{name=LELabel43, type=boolean, expr=0 < 0, size=0}}
{GE(>), 0, 0, Result: VarLocation{name=GELabel47, type=boolean, expr=0 > 0, size=0}}
{OR(||), VarLocation{name=LELabel43, type=boolean, expr=0 < 0, size=0}, VarLocation{name=GELabel47, type=boolean, expr=0 > 0, size=0}, Result: VarLocation{name=DISYUNCIONLabel49, type=boolean, expr=VarLocation{name=LELabel43, type=boolean, expr=0 < 0, size=0} || VarLocation{name=GELabel47, type=boolean, expr=0 > 0, size=0}, size=0}}
{LABEL, null, null, Result: BeginWhileLabel51}
{CMP, VarLocation{name=factorLabel50, type=boolean, expr=VarLocation{name=DISYUNCIONLabel49, type=boolean, expr=VarLocation{name=LELabel43, type=boolean, expr=0 < 0, size=0} || VarLocation{name=GELabel47, type=boolean, expr=0 > 0, size=0}, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel52}
{LE(<), 0, 0, Result: VarLocation{name=LELabel55, type=boolean, expr=0 < 0, size=0}}
{CMP, VarLocation{name=LELabel55, type=boolean, expr=0 < 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel56}
{null, 1, null, Result: IntLiteralLabel59}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel61, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=x, type=int, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel57}
{LABEL, null, null, Result: elseCondLabel56}
{CEQ(==), 0, 0, Result: VarLocation{name=CEQLabel64, type=boolean, expr=0 == 0, size=0}}
{CMP, VarLocation{name=CEQLabel64, type=boolean, expr=0 == 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel65}
{null, 1, null, Result: IntLiteralLabel68}
{MINUS(-), 0, 1, Result: VarLocation{name=MINUSLabel70, type=int, expr=0 - 1, size=0}}
{MULTIPLY(*), 0, 0, Result: VarLocation{name=MULTIPLYLabel73, type=int, expr=0 * 0, size=0}}
{MULTIPLY(*), 0, 0, Result: VarLocation{name=MULTIPLYLabel76, type=int, expr=0 * 0, size=0}}
{MINUS(-), 0 * 0, 0 * 0, Result: VarLocation{name=MINUSLabel77, type=int, expr=0 * 0 - 0 * 0, size=0}}
{PLUS(+), 0 - 1, VarLocation{name=MINUSLabel77, type=int, expr=0 * 0 - 0 * 0, size=0}, Result: VarLocation{name=PLUSLabel79, type=int, expr=0 - 1 + VarLocation{name=MINUSLabel77, type=int, expr=0 * 0 - 0 * 0, size=0}, size=0}}
{ASSIGN(=), 0 - 1 + VarLocation{name=MINUSLabel77, type=int, expr=0 * 0 - 0 * 0, size=0}, null, Result: VarLocation{name=x, type=int, expr=null, size=0}}
{JMP, null, null, Result: endIfLabel66}
{LABEL, null, null, Result: elseCondLabel65}
{LABEL, null, null, Result: endIfLabel66}
{LABEL, null, null, Result: endIfLabel57}
{JMP, null, null, Result: BeginWhileLabel51}
{LABEL, null, null, Result: EndWhileLabel52}
{ASSIGN(=), 0, null, Result: VarLocation{name=x, type=int, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel82}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel84, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=j, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel10}
{LABEL, null, null, Result: EndWhileLabel11}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod id}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 9, null, Result: IntLiteralLabel86}
{METHODCALL, id, 1, Result: RESULTLabel88}
{PARAM, null, null, Result: 9}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=id, args=[9]}]}, null, Result: EXTERNINVKLabel90}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.BinOpExpr y class ir.ast.BinOpExpr PENDIENTE


.globl	id
.type	id, @function 
id: 
    enter   $(4), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $100, IntLiteralLabel1(%rbp)

    mov 100(%rbp), %eax
    mov -4(%rbp), %eax

    movl $0, IntLiteralLabel3(%rbp)

    mov 0(%rbp), %eax
    mov -12(%rbp), %eax

    mov 0(%rbp), %eax
    mov -20(%rbp), %eax

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -36(%rbp)

.BeginWhileLabel10

    mov true(%rbp), %eax
    cmp -40(%rbp), %eax

    jne EndWhileLabel11

    mov 0(%rbp), %eax
    mov -44(%rbp), %eax

    movl $0, IntLiteralLabel14(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -60(%rbp)

    movl $0, IntLiteralLabel19(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -76(%rbp)

    cmp	$0, -60(%rbp)
    jne .L0
    cmp	$0, -76(%rbp)
    je .L0
    mov	$1, %eax
    jmp .L1
.L0:
    movl	$0, %eax
    jmp .L2
.L1:
    movl	%eax, -84(%rbp)
.L2:

.BeginWhileLabel25

    mov true(%rbp), %eax
    cmp -88(%rbp), %eax

    jne EndWhileLabel26

    movl $0, IntLiteralLabel28(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -100(%rbp)

    mov true(%rbp), %eax
    cmp -100(%rbp), %eax

    jne elseCondLabel31

    movl $1, IntLiteralLabel34(%rbp)

    mov $0, %eax
    mov $1, %edx
    sub %eax, %edx
    mov %edx,-116%(ebp)

    mov 0 - 1(%rbp), %eax
    mov -104(%rbp), %eax

    jmp endIfLabel32

.elseCondLabel31

    movl $1, IntLiteralLabel38(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-132%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -120(%rbp), %eax

.endIfLabel32

    jmp BeginWhileLabel25

.EndWhileLabel26

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -144(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setg	%al
    movzbl %al, %eax
    movl	%eax, -160(%rbp)

    cmp	$0, -144(%rbp)
    jne .L3
    cmp	$0, -160(%rbp)
    je .L3
    mov	$1, %eax
    jmp .L4
.L3:
    movl	$0, %eax
    jmp .L5
.L4:
    movl	%eax, -168(%rbp)
.L5:

.BeginWhileLabel51

    mov true(%rbp), %eax
    cmp -172(%rbp), %eax

    jne EndWhileLabel52

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -184(%rbp)

    mov true(%rbp), %eax
    cmp -184(%rbp), %eax

    jne elseCondLabel56

    movl $1, IntLiteralLabel59(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-200%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -188(%rbp), %eax

    jmp endIfLabel57

.elseCondLabel56

    movl	$0, %eax
    cmpl	$0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -212(%rbp)

    mov true(%rbp), %eax
    cmp -212(%rbp), %eax

    jne elseCondLabel65

    movl $1, IntLiteralLabel68(%rbp)

    mov $0, %eax
    mov $1, %edx
    sub %eax, %edx
    mov %edx,-228%(ebp)

    mov $0, %eax
    mov $0, %edx
    imul %edx, %eax
    mov %eax,-240%(ebp)

    mov $0, %eax
    mov $0, %edx
    imul %edx, %eax
    mov %eax,-252%(ebp)



    mov 0 - 1 + VarLocation{name=MINUSLabel77, type=int, expr=0 * 0 - 0 * 0, size=0}(%rbp), %eax
    mov -216(%rbp), %eax

    jmp endIfLabel66

.elseCondLabel65

.endIfLabel66

.endIfLabel57

    jmp BeginWhileLabel51

.EndWhileLabel52

    mov 0(%rbp), %eax
    mov -268(%rbp), %eax

    movl $1, IntLiteralLabel82(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-288%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -276(%rbp), %eax

    jmp BeginWhileLabel10

.EndWhileLabel11

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $9, IntLiteralLabel86(%rbp)

    call id
    movl %eax, RESULTLabel88(%rbp) 

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel90(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_suma.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -28
OFFSET = -44

parseo exitoso
tamaño lista de codigo tercetos: 30
lista: 
{LABEL, null, null, Result: BeginMethod suma}

{METHODDECL, Metodo{ name=suma, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=num1, value=null, size=0}, Simbolo{type=int, name=num2, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel2}
{CEQ(==), 0, 0, Result: VarLocation{name=CEQLabel4, type=boolean, expr=0 == 0, size=0}}
{CMP, VarLocation{name=CEQLabel4, type=boolean, expr=0 == 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel5}
{RETURN, null, null, Result: 0}
{JMP, null, null, Result: endIfLabel6}
{LABEL, null, null, Result: elseCondLabel5}
{null, 0, null, Result: IntLiteralLabel9}
{CEQ(==), 0, 0, Result: VarLocation{name=CEQLabel11, type=boolean, expr=0 == 0, size=0}}
{CMP, VarLocation{name=CEQLabel11, type=boolean, expr=0 == 0, size=0}, true, Result: null}
{JNE, null, null, Result: elseCondLabel12}
{RETURN, null, null, Result: 0}
{JMP, null, null, Result: endIfLabel13}
{LABEL, null, null, Result: elseCondLabel12}
{PLUS(+), 0, 0, Result: VarLocation{name=PLUSLabel17, type=int, expr=0 + 0, size=0}}
{RETURN, null, null, Result: 0 + 0}
{LABEL, null, null, Result: endIfLabel13}
{LABEL, null, null, Result: endIfLabel6}
{LABEL, null, null, Result: EndMethod suma}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 4, null, Result: IntLiteralLabel18}
{null, 9, null, Result: IntLiteralLabel20}
{METHODCALL, suma, 2, Result: RESULTLabel22}
{PARAM, null, null, Result: 4}
{PARAM, null, null, Result: 9}
{EXTERNINVK, ExternInvkExpr{id="printf", type=int, parameters=[MethodCallExpr{name=suma, args=[4, 9]}]}, null, Result: EXTERNINVKLabel24}
{LABEL, null, null, Result: EndMethod main}



.globl	suma
.type	suma, @function 
suma: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel2(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -12(%rbp)

    mov true(%rbp), %eax
    cmp -12(%rbp), %eax

    jne elseCondLabel5

    mov 0(%rbp), %eax

    jmp endIfLabel6

.elseCondLabel5

    movl $0, IntLiteralLabel9(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    sete %al
    movzbl %al, %eax
    movl	%eax, -28(%rbp)

    mov true(%rbp), %eax
    cmp -28(%rbp), %eax

    jne elseCondLabel12

    mov 0(%rbp), %eax

    jmp endIfLabel13

.elseCondLabel12

    mov $0, %eax 
    mov $0, %edx 
    add %eax, %edx 
    mov %edx,-44%(ebp) 

    mov 0 + 0(%rbp), %eax

.endIfLabel13

.endIfLabel6

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $4, IntLiteralLabel18(%rbp)

    movl $9, IntLiteralLabel20(%rbp)

    call suma
    movl %eax, RESULTLabel22(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel24(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_sumx.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -28
OFFSET = -36
OFFSET = -48
OFFSET = -52
OFFSET = -64

parseo exitoso
tamaño lista de codigo tercetos: 28
lista: 
{LABEL, null, null, Result: BeginMethod sumx}

{METHODDECL, Metodo{ name=sumx, return_not_void=true, typeReturn=float, parameters [Simbolo{type=float, name=x, value=null, size=0}, Simbolo{type=int, name=n, value=null, size=0}]}, null, Result: null}
{null, 0, null, Result: IntLiteralLabel1}
{ASSIGN(=), 0, null, Result: VarLocation{name=aux, type=float, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel3}
{ASSIGN(=), 0, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{LE(<), 0, 0, Result: VarLocation{name=LELabel7, type=boolean, expr=0 < 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel9}
{CMP, VarLocation{name=factorLabel8, type=boolean, expr=VarLocation{name=LELabel7, type=boolean, expr=0 < 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel10}
{PLUS(+), 0.0, 0.0, Result: VarLocation{name=PLUSLabel13, type=float, expr=0.0 + 0.0, size=0}}
{ASSIGN(=), 0.0 + 0.0, null, Result: VarLocation{name=aux, type=float, expr=null, size=0}}
{null, 1, null, Result: IntLiteralLabel15}
{PLUS(+), 0, 1, Result: VarLocation{name=PLUSLabel17, type=int, expr=0 + 1, size=0}}
{ASSIGN(=), 0 + 1, null, Result: VarLocation{name=i, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel9}
{LABEL, null, null, Result: EndWhileLabel10}
{RETURN, null, null, Result: 0.0}
{LABEL, null, null, Result: EndMethod sumx}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 6.0, null, Result: FloatLiteralLabel19}
{null, 2, null, Result: IntLiteralLabel21}
{METHODCALL, sumx, 2, Result: RESULTLabel23}
{PARAM, null, null, Result: 6.0}
{PARAM, null, null, Result: 2}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[MethodCallExpr{name=sumx, args=[6.0, 2]}]}, null, Result: EXTERNINVKLabel25}
{LABEL, null, null, Result: EndMethod main}

{Add}TRATAMIENTO PARA class ir.ast.FloatLiteral y class ir.ast.FloatLiteral PENDIENTE


.globl	sumx
.type	sumx, @function 
sumx: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $0, IntLiteralLabel1(%rbp)

    mov 0(%rbp), %eax
    mov -4(%rbp), %eax

    movl $0, IntLiteralLabel3(%rbp)

    mov 0(%rbp), %eax
    mov -12(%rbp), %eax

    movl	$0, %eax
    cmpl	$0, %eax
    setl	%al
    movzbl %al, %eax
    movl	%eax, -28(%rbp)

.BeginWhileLabel9

    mov true(%rbp), %eax
    cmp -32(%rbp), %eax

    jne EndWhileLabel10


    mov 0.0 + 0.0(%rbp), %eax
    mov -36(%rbp), %eax

    movl $1, IntLiteralLabel15(%rbp)

    mov $0, %eax 
    mov $1, %edx 
    add %eax, %edx 
    mov %edx,-64%(ebp) 

    mov 0 + 1(%rbp), %eax
    mov -52(%rbp), %eax

    jmp BeginWhileLabel9

.EndWhileLabel10

    mov 0.0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $6.0, FloatLiteralLabel19(%rbp)

    movl $2, IntLiteralLabel21(%rbp)

    call sumx
    movl %eax, RESULTLabel23(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel25(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
---------------- Test tests/test_correctos/test_while.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20
OFFSET = -44
OFFSET = -56
OFFSET = -60
OFFSET = -76
OFFSET = -88

parseo exitoso
tamaño lista de codigo tercetos: 41
lista: 
{LABEL, null, null, Result: BeginMethod maxcomdiv}

{METHODDECL, Metodo{ name=maxcomdiv, return_not_void=true, typeReturn=int, parameters [Simbolo{type=int, name=a, value=null, size=0}, Simbolo{type=int, name=b, value=null, size=0}]}, null, Result: null}
{null, 1, null, Result: IntLiteralLabel1}
{ASSIGN(=), 1, null, Result: VarLocation{name=resto, type=int, expr=null, size=0}}
{null, 0, null, Result: IntLiteralLabel4}
{NEQ(!=), 0, 0, Result: VarLocation{name=NEQLabel6, type=boolean, expr=0 != 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel12}
{CMP, VarLocation{name=factorLabel11, type=boolean, expr=VarLocation{name=factorLabel10, type=boolean, expr=VarLocation{name=factorLabel9, type=boolean, expr=VarLocation{name=factorLabel8, type=boolean, expr=VarLocation{name=factorLabel7, type=boolean, expr=VarLocation{name=NEQLabel6, type=boolean, expr=0 != 0, size=0}, size=0}, size=0}, size=0}, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel13}
{MOD(%), 0, 0, Result: VarLocation{name=MODLabel16, type=int, expr=0 % 0, size=0}}
{ASSIGN(=), 0 % 0, null, Result: VarLocation{name=resto, type=int, expr=null, size=0}}
{ASSIGN(=), 0, null, Result: VarLocation{name=dividendo, type=int, expr=null, size=0}}
{JMP, null, null, Result: BeginWhileLabel12}
{JMP, null, null, Result: BeginWhileLabel12}
{LABEL, null, null, Result: EndWhileLabel13}
{null, 0, null, Result: IntLiteralLabel19}
{NEQ(!=), 0, 0, Result: VarLocation{name=NEQLabel21, type=boolean, expr=0 != 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel22}
{CMP, VarLocation{name=NEQLabel21, type=boolean, expr=0 != 0, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel23}
{JMP, null, null, Result: EndWhileLabel23}
{JMP, null, null, Result: BeginWhileLabel22}
{LABEL, null, null, Result: EndWhileLabel23}
{null, 0, null, Result: IntLiteralLabel25}
{NEQ(!=), 0, 0, Result: VarLocation{name=NEQLabel27, type=boolean, expr=0 != 0, size=0}}
{LABEL, null, null, Result: BeginWhileLabel29}
{CMP, VarLocation{name=factorLabel28, type=boolean, expr=VarLocation{name=NEQLabel27, type=boolean, expr=0 != 0, size=0}, size=0}, true, Result: null}
{JNE, null, null, Result: EndWhileLabel30}
{JMP, null, null, Result: BeginWhileLabel29}
{LABEL, null, null, Result: EndWhileLabel30}
{RETURN, null, null, Result: 0}
{LABEL, null, null, Result: EndMethod maxcomdiv}
{LABEL, null, null, Result: BeginMethod main}

{METHODDECL, Metodo{ name=main, return_not_void=true, typeReturn=int, parameters []}, null, Result: null}
{null, 6, null, Result: IntLiteralLabel32}
{null, 9, null, Result: IntLiteralLabel34}
{METHODCALL, maxcomdiv, 2, Result: RESULTLabel36}
{PARAM, null, null, Result: 6}
{PARAM, null, null, Result: 9}
{EXTERNINVK, ExternInvkExpr{id="printf", type=float, parameters=[StringLiteral{value="%dMcd"}, MethodCallExpr{name=maxcomdiv, args=[6, 9]}]}, null, Result: EXTERNINVKLabel38}
{LABEL, null, null, Result: EndMethod main}



.globl	maxcomdiv
.type	maxcomdiv, @function 
maxcomdiv: 
    enter   $(8), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $1, IntLiteralLabel1(%rbp)

    mov 1(%rbp), %eax
    mov -4(%rbp), %eax

    movl $0, IntLiteralLabel4(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setgne %al
    movzbl %al, %eax
    movl	%eax, -20(%rbp)

.BeginWhileLabel12

    mov true(%rbp), %eax
    cmp -40(%rbp), %eax

    jne EndWhileLabel13

    movl	$0, %eax 
    idivl $0, %eax 
    movl	%edx, -56(%rbp)

    mov 0 % 0(%rbp), %eax
    mov -44(%rbp), %eax

    mov 0(%rbp), %eax
    mov -60(%rbp), %eax

    jmp BeginWhileLabel12

    jmp BeginWhileLabel12

.EndWhileLabel13

    movl $0, IntLiteralLabel19(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setgne %al
    movzbl %al, %eax
    movl	%eax, -76(%rbp)

.BeginWhileLabel22

    mov true(%rbp), %eax
    cmp -76(%rbp), %eax

    jne EndWhileLabel23

    jmp EndWhileLabel23

    jmp BeginWhileLabel22

.EndWhileLabel23

    movl $0, IntLiteralLabel25(%rbp)

    movl	$0, %eax
    cmpl	$0, %eax
    setgne %al
    movzbl %al, %eax
    movl	%eax, -88(%rbp)

.BeginWhileLabel29

    mov true(%rbp), %eax
    cmp -92(%rbp), %eax

    jne EndWhileLabel30

    jmp BeginWhileLabel29

.EndWhileLabel30

    mov 0(%rbp), %eax

    leave
    ret



.globl	main
.type	main, @function 
main: 
    enter   $(0), $0 
    push	%rbp
    mov %rsp, %rbp

    movl $6, IntLiteralLabel32(%rbp)

    movl $9, IntLiteralLabel34(%rbp)

    call maxcomdiv
    movl %eax, RESULTLabel36(%rbp) 

PARAM

PARAM

    call "printf"
    movl %eax, EXTERNINVKLabel38(%rbp) 

    leave
    ret


---------------------------------------------------
  
  
///////////////////////// TESTS CON FALLAS ////////////////////////////////////////
---------------- Test tests/test_errores/error_arreglos01.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 3.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_arreglos02.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 3.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_arreglos03.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 7.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_arreglos04.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 3.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_arreglos05.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 3.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_bloques01.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 3.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_bloques02.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 9.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_char.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 4.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_class01.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -16
Error: Method alo not declared
OFFSET = -4
Error: Method alo not declared
ocurrio un error: null
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_class02.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -16
Error: Method alo not declared
OFFSET = -4
Error: Method alo not declared
ocurrio un error: null
---------------------------------------------------
  
  
---------------- Test tests/test_errores/errores.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 3.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_externinvk02.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -28
OFFSET = -36
OFFSET = -48
OFFSET = -52
OFFSET = -64
error de sintaxis: Linea 23.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_externinvk.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -28
OFFSET = -36
OFFSET = -48
OFFSET = -52
OFFSET = -64
error de sintaxis: Linea 22.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_float01.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 9.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_float02.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
error: 0 9 .
OFFSET = -36
OFFSET = -40
OFFSET = -48
OFFSET = -52
OFFSET = -60
OFFSET = -72
OFFSET = -80
OFFSET = -92
OFFSET = -96
OFFSET = -108
OFFSET = -116
OFFSET = -124
error: 0 21 .
error de sintaxis: Linea 22.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_float03.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -36
OFFSET = -40
OFFSET = -48
OFFSET = -52
OFFSET = -68
OFFSET = -80
OFFSET = -84
OFFSET = -92
OFFSET = -104
OFFSET = -112
OFFSET = -116
OFFSET = -128
error de sintaxis: Linea 29.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_float04.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -20
OFFSET = -36
OFFSET = -40
OFFSET = -48
OFFSET = -52
OFFSET = -68
OFFSET = -80
OFFSET = -84
OFFSET = -92
OFFSET = -104
OFFSET = -112
OFFSET = -116
OFFSET = -128
OFFSET = -144
OFFSET = -156
error de sintaxis: Linea 41.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_for01.ctds ... -------------------
parseo iniciado
OFFSET = -8
error de sintaxis: Linea 13.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_for02.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -36
error de sintaxis: Linea 13.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_for03.ctds ... -------------------
parseo iniciado
OFFSET = -8
error de sintaxis: Linea 13.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_for04.ctds ... -------------------
parseo iniciado
OFFSET = -8
error de sintaxis: Linea 13.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_for05.ctds ... -------------------
parseo iniciado
OFFSET = -8
error de sintaxis: Linea 18.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_if01.ctds ... -------------------
parseo iniciado
OFFSET = -12
error de sintaxis: Linea 9.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_if02.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 8.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_lineaerror02.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -24
OFFSET = -36
OFFSET = -44
error de sintaxis: Linea 20.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_lineaerror.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -24
OFFSET = -36
OFFSET = -44
error de sintaxis: Linea 20.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_break.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -20
OFFSET = -28
OFFSET = -40
OFFSET = -52
OFFSET = -56
OFFSET = -64
error de sintaxis: Linea 20.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_logicos02.ctds ... -------------------
parseo iniciado
OFFSET = -12
error: 0 4 &
error de sintaxis: Linea 5.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_logicos.ctds ... -------------------
parseo iniciado
OFFSET = -12
OFFSET = -28
OFFSET = -36
OFFSET = -48
OFFSET = -60
OFFSET = -72
OFFSET = -88
OFFSET = -96
OFFSET = -108
OFFSET = -120
ocurrio un error: null
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_main01.ctds ... -------------------
parseo iniciado
Error: Method alo not declared
error de sintaxis: Linea 11.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_main02.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -16
Error: Method Main must not have parameters
Error: Method alo not declared
error de sintaxis: Linea 14.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_metodos01.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 4.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_metodos02.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 4.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_metodos03.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -16
OFFSET = -12
OFFSET = -24
OFFSET = -4
OFFSET = -12
OFFSET = -24
OFFSET = -28
error de sintaxis: Linea 19.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_metodos04.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -20
OFFSET = -24
OFFSET = -32
OFFSET = -40
Error: Method alo3 not declared
OFFSET = -12
OFFSET = -24
error de sintaxis: Linea 21.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_metodos05.ctds ... -------------------
parseo iniciado
OFFSET = -8
OFFSET = -20
OFFSET = -24
OFFSET = -36
error de sintaxis: Linea 15.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_metodos06.ctds ... -------------------
parseo iniciado
error: 0 3 &
error de sintaxis: Linea 4.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_metodos07.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 9.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_test_multiplesMain.ctds ... -------------------
parseo iniciado
OFFSET = -4
OFFSET = -12
OFFSET = -24
error de sintaxis: Linea 9.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_vbles01.ctds ... -------------------
parseo iniciado
error de sintaxis: Linea 6.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_vbles02.ctds ... -------------------
parseo iniciado
error: 0 5 _
error de sintaxis: Linea 7.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/error_vbles03.ctds ... -------------------
error de sintaxis: Linea 3.
---------------------------------------------------
  
  
---------------- Test tests/test_errores/ifErrorTest.ctds ... -------------------
parseo iniciado
OFFSET = -12
error de sintaxis: Linea 6.
---------------------------------------------------
  
  
