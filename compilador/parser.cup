/*
Proyecto: Proyecto Compiladores 2014
Autores: Federico Franco, Bruno Isoardi
Funcionalidad: Clase que lleva acabo el analisis sintactico
*/
import java_cup.runtime.Symbol;
import ir.*;
import ir.ast.*;


action code{: 

AST ast;

symbolTable TS; //tabla de simbolos

Type tipo_corriente; //ultimo tipo leido

Metodo ult_metodo; //ultimo metodo creado

boolean mainDeclared;

:};

parser code{:

public void syntax_error(Symbol s){
    System.out.println("error de sintaxis: Linea "+(s.right+1)+".");
}

public void unrecovered_syntax_error (Symbol s) throws java.lang.Exception{
}
:};


/*Declaracion de variables no terminales*/
non terminal program,field_decl,method_decl,block,type,statement,method_call,externinvk_arg,
literal, bool_LITERAL, type_or_void, else_block;

non terminal body, fieldDeclarations, fieldAndMethods, identifier, identifiers, methodDeclarations, parameters, 
parameterDeclarations, parameterDeclaration, statements, expressions, externinvk_args, conjunction, comparison, term, sum,
relation;

non terminal Location location;
non terminal Expression expr;
non terminal AssignOpType assign_op;
non terminal Expression factor;

/*DECLARACION DE VARIABLES TERMINALES */

/*Terminales palabras reservadas*/
terminal CLASS, ELSE, VOID;
terminal String ID;
terminal BoolLiteral FALSE, TRUE;
terminal IfStmt IF;
terminal BreakStmt BREAK;
terminal ContinueStmt CONTINUE;
terminal ForStmt FOR;
terminal ReturnStmt RETURN;
terminal WhileStmt WHILE;

/*Terminales operadores aritméticos y lógicos*/
terminal BinOpType SUMA, RESTA, MULTIPLICACION, DIVISION,  PORCENTAJE;
terminal AssignOpType ASIGNACION, INCREMENTO, DECREMENTO;

/*Terminales operadores lógicos*/
terminal BinOpType CONJUNCION, DISYUNCION, IGUALDAD_LOGICA, DIFERENCIA_LOGICA, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL;

/*Terminales signos de puntuación*/
terminal  COMA, PUNTO_Y_COMA, LLAVE_IZQ, LLAVE_DER, CORCHETE_IZQ, CORCHETE_DER, PARENTESIS_IZQ, PARENTESIS_DER, ADMIRACION; 

/*Terminales tipos*/
terminal INT, FLOAT, BOOLEAN;

/*Terminales varios*/
terminal EXTERNINVK;

/*Terminales objetos*/
terminal String INT_LITERAL;
terminal String FLOAT_LITERAL;
terminal String STRING_LITERAL;

precedence left LLAVE_IZQ, LLAVE_DER;
precedence left CORCHETE_IZQ, CORCHETE_DER;
precedence right INCREMENTO;
precedence right DECREMENTO;
precedence right ASIGNACION;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence left DIFERENCIA_LOGICA, IGUALDAD_LOGICA;
precedence left MENOR_IGUAL, MAYOR_IGUAL;
precedence left MENOR, MAYOR;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, PORCENTAJE;
precedence left PARENTESIS_IZQ, PARENTESIS_DER;
precedence left ADMIRACION;

start with program;

program::= CLASS ID:d {: mainDeclared=false;  :} body {:if(mainDeclared){System.out.println("parseo exitoso");}else{System.out.println("Main Method Missing in Class "+d.toString());}:}
        ;

body::= LLAVE_IZQ LLAVE_DER 
    | LLAVE_IZQ {: TS = new symbolTable(); :} fieldAndMethods LLAVE_DER 
    ;

fieldAndMethods::= fieldDeclarations
               | methodDeclarations
               | fieldDeclarations methodDeclarations
               ;

fieldDeclarations::= field_decl
                 | fieldDeclarations field_decl
                 ;

field_decl::= type identifiers PUNTO_Y_COMA
          ;

identifiers::= identifier
            | identifiers COMA identifier
            ;

identifier::= ID:s {: TS.agregarSimbolo(tipo_corriente, s.toString(), null, 0); :} 
  | ID:s CORCHETE_IZQ INT_LITERAL:i CORCHETE_DER {: int size= Integer.valueOf((String) i); switch (tipo_corriente){
                                                       case INT:
                                                               TS.agregarSimbolo(Type.INTARRAY, s.toString(), null, size);  
                                                               break;
                                                       case FLOAT:
                                                               TS.agregarSimbolo(Type.FLOATARRAY, s.toString(), null, size);  
                                                               break;
                                                       case BOOLEAN:
                                                               TS.agregarSimbolo(Type.BOOLARRAY, s.toString(), null, size); 
                                                               break;
                                                                           }:} 
  ;

methodDeclarations::= method_decl
                  | methodDeclarations method_decl
                  ;

method_decl::= VOID ID:d {: 
                    if(d.toString().equals("main")){
                        mainDeclared=true;
                    } 
                    TS.agregarMetodo(Type.VOID, d.toString()); :} parameters {:
                    Metodo e=TS.obtenerMetodo();
                    ult_metodo=e;
                    TS.agregarNivel();
                    for(int i=0; i<e.getParametros().size(); i++){
                        Simbolo actual = e.getParametros().get(i);
                        TS.agregarSimbolo(actual.getType(), actual.getName(), actual.getValue(), actual.getSize());
                   }         :} block {: TS.SubirNivel(); :}
           | type ID:g {:if(g.toString().equals("main")){mainDeclared=true;} switch (tipo_corriente){
                              case INT:
                                        TS.agregarMetodo(Type.INT, g.toString());
                                        break;
                              case FLOAT:
                                        TS.agregarMetodo(Type.FLOAT, g.toString());  
                                        break;
                              case BOOLEAN:
                                        TS.agregarMetodo(Type.BOOLEAN, g.toString()); 
                                        break;
                                                 }:} parameters {:Metodo e=TS.obtenerMetodo();
                                                 ult_metodo=TS.obtenerMetodo();   
                    TS.agregarNivel();
                    for(int i=0; i<e.getParametros().size(); i++){
                        Simbolo actual = e.getParametros().get(i);
                        TS.agregarSimbolo(actual.getType(), actual.getName(), actual.getValue(), actual.getSize());
                    }
                   :} block {:TS.SubirNivel();:}
           ;

block::= LLAVE_IZQ LLAVE_DER
     | LLAVE_IZQ statements LLAVE_DER
     | LLAVE_IZQ fieldDeclarations LLAVE_DER
     | LLAVE_IZQ fieldDeclarations statements LLAVE_DER
     ;


parameters::= PARENTESIS_IZQ PARENTESIS_DER
          | PARENTESIS_IZQ parameterDeclarations PARENTESIS_DER
          ;
            

parameterDeclarations::= parameterDeclaration
                     | parameterDeclarations COMA parameterDeclaration
                     ;

parameterDeclaration::= type ID:a {: Simbolo sym = new Simbolo(tipo_corriente, a.toString(), null, 0); 
                                      TS.obtenerMetodo().addParametro(sym); :}
                    ;

statements::= statement
          | statements statement
          ;
                    
type::= INT {:tipo_corriente = Type.INT; :} 
    | FLOAT {:tipo_corriente = Type.FLOAT; :}
    | BOOLEAN {:tipo_corriente = Type.BOOLEAN; :}
    ;

statement::= location:l assign_op:ao expr:e PUNTO_Y_COMA {: AssignStmt a=new AssignStmt((Location)l, (AssignOpType) ao, (Expression) e); RESULT=a; :}
         | method_call PUNTO_Y_COMA
         | IF PARENTESIS_IZQ {: TS.agregarNivel(); :} expr PARENTESIS_DER block {: TS.SubirNivel(); :} else_block
         | FOR ID ASIGNACION expr COMA expr {: TS.agregarNivel(); :}  block {: TS.SubirNivel(); :}
         | WHILE expr {: TS.agregarNivel(); :}  block {: TS.SubirNivel(); :}
         | RETURN PUNTO_Y_COMA {:
                               if(!ult_metodo.getTypeReturn().equals(Type.VOID)){
                                        System.out.println("Error: Method "+ult_metodo.getName()+" returns void ");
                               }else{ 
                                    System.out.println("deberia retornar ReturnStmt con void");
                                /*RESULT= new ResultStmt(void)*/;} :}
         | RETURN expr:e PUNTO_Y_COMA {: 
                                        System.out.println("EXPRESSION STATEMENT RETURN ="+e);
                                        /*if(!e.getType().equals(ult_metodo.getTypeReturn())){
                                            System.out.println("Error: Method "+ult_metodo.getName()+" must return "+ult_metodo.getTypeReturn().toString());
                                        }else{
                                            System.out.println("deberia retornar ReturnStmt con el tipo");
                                            //RESULT= new ReturnStmt(e);
                                        }*/
                                        :}
         | BREAK PUNTO_Y_COMA
         | CONTINUE PUNTO_Y_COMA
         | PUNTO_Y_COMA
         | {: TS.agregarNivel(); :}  block {: TS.SubirNivel(); :}
         ;

else_block::= ELSE {: TS.agregarNivel(); :} block {: TS.SubirNivel(); :} 
          |
          ;

assign_op::= ASIGNACION {: RESULT= AssignOpType.ASSIGN; :}
         | INCREMENTO {: RESULT= AssignOpType.INCREMENT; :}
         | DECREMENTO {: RESULT= AssignOpType.DECREMENT; :}
         ;

method_call::= ID PARENTESIS_IZQ PARENTESIS_DER
           |  ID PARENTESIS_IZQ expressions PARENTESIS_DER
           |  EXTERNINVK PARENTESIS_IZQ STRING_LITERAL COMA type_or_void COMA externinvk_args PARENTESIS_DER
           |  EXTERNINVK PARENTESIS_IZQ STRING_LITERAL COMA type_or_void PARENTESIS_DER
           ;

type_or_void::= type
            | VOID
            ;

expressions::= expr
           | expressions COMA expr
           ;

externinvk_args::= externinvk_arg
               | externinvk_args COMA externinvk_arg 
               ;

externinvk_arg::= expr
              | STRING_LITERAL
              ;

location::= ID:id {: System.out.println("location "+id);
                    Simbolo s=TS.buscarSimbolo((String)id); 
                        if(s==null){
                            System.out.println("variable "+id+" not declared");
                            RESULT=null;
                        }else{
                            RESULT= new VarLocation((String)id,s.getType(),s.getValue(),s.getSize());
                        }
             :} //usos de variables
        | ID CORCHETE_IZQ expr CORCHETE_DER
        ;

expr::= conjunction
    | expr DISYUNCION conjunction
    ;

conjunction::= comparison
           | conjunction CONJUNCION comparison
           ;

comparison::= relation
          | relation IGUALDAD_LOGICA relation
          | relation DIFERENCIA_LOGICA relation
          ;

relation::= sum
        | sum MENOR sum
        | sum MAYOR sum
        | sum MAYOR_IGUAL sum
        | sum MENOR_IGUAL sum
        ;

sum::= term
   | sum SUMA term
   | sum RESTA term
   ;

term::= factor
    | term MULTIPLICACION factor 
    | term DIVISION factor
    | term PORCENTAJE factor
    ;

factor::=literal:l {: RESULT = (Expression)l; :} 
      | ADMIRACION factor:f {:  
                                System.out.println("valor factor : "+f);
                                UnaryOpExpr f2=null;
                                if(f.getType().equals(Type.BOOLEAN)){
                                    f2=new UnaryOpExpr(UnaryOpType.NON, f);
                                    System.out.println("valor de f2: "+f2 ); 
                                    RESULT=f2;
                                }else{
                                    System.out.println("Boolean expected but "+f.getType().toString()+" found.");
                                } :}
      | RESTA factor /*{:  if(f.getType().equals(Type.FLOAT)){ 
                                    FloatLiteral f2=(FloatLiteral)f;
                                    float v=f2.getValue()*-1;
                                    RESULT=new FloatLiteral(String.valueOf(v));
                                }else{
                                    if(f.getType().equals(Type.INT)){
                                        IntLiteral f2=(IntLiteral)f;
                                        int v=f2.getValue()*-1;
                                        RESULT=new IntLiteral(String.valueOf(v));
                                    }else{
                                        System.out.println("Numeral (int or float) expected but "+f.getType().toString()+" found.");
                                    }
                                }   
                                 :}*/
      ;


literal::= INT_LITERAL:i {: RESULT= new IntLiteral((String) i); :}
       | FLOAT_LITERAL:f {:RESULT= new FloatLiteral((String) f); :}
       | bool_LITERAL:b {:RESULT = b; System.out.println("entro aca (BOOL_LITERAL)"+b.toString());:}
       | ID:id {: Simbolo s=TS.buscarSimbolo(id);
                    switch(s.getType()){
                        case BOOLEAN:
                            if(s.getValue()==null){
                                System.out.println("boolean sin valor");
                                RESULT= new BoolLiteral(false);
                            }else{
                                System.out.println("boolean con valor");
                                RESULT= new BoolLiteral(Boolean.valueOf(s.getValue()));
                            }
                            break;
                        case INT:
                            if(s.getValue()==null){
                                System.out.println("int sin valor");
                                RESULT= new IntLiteral("0");
                            }else{
                                System.out.println("int con valor");
                                RESULT= new IntLiteral(s.getValue());
                            }
                            break;
                        case FLOAT:
                            if(s.getValue()==null){
                                System.out.println("float sin valor");
                                RESULT= new FloatLiteral("0.0");
                            }else{
                                System.out.println("float con valor");
                                RESULT= new FloatLiteral(s.getValue());
                            }
                            break;
                        case STRING:
                            if(s.getValue()==null){
                                System.out.println("string sin valor");
                                RESULT= new StringLiteral("");
                            }else{
                                System.out.println("string con valor");
                                RESULT= new StringLiteral(s.getValue());
                            }
                            break;
                    }
                 :}
       | ID CORCHETE_IZQ expr CORCHETE_DER
       | method_call
       | PARENTESIS_IZQ expr PARENTESIS_DER
       ;

bool_LITERAL::= TRUE {:RESULT= new BoolLiteral(true); :} 
            | FALSE {: RESULT= new BoolLiteral(false); :}
            ;

