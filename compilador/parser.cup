/*
Proyecto: Proyecto Compiladores 2014
Autores: Federico Franco, Bruno Isoardi
Funcionalidad: Clase que lleva acabo el analisis sintactico
*/
import java_cup.runtime.Symbol;
import ir.*;
import ir.ast.*;


action code{: 

AST ast;

symbolTable TS; //tabla de simbolos

Tipo tipo_corriente; //ultimo tipo leido

Metodo ult_metodo; //ultimo metodo creado

boolean mainDeclared;

:};

parser code{:

public void syntax_error(Symbol s){
    System.out.println("error de sintaxis: Linea "+(s.right+1)+".");
}

public void unrecovered_syntax_error (Symbol s) throws java.lang.Exception{
}
:};


/*Declaracion de variables no terminales*/
non terminal program,field_decl,method_decl,block,type,statement,method_call,externinvk_arg,
literal, bool_LITERAL, type_or_void, else_block;

non terminal body, fieldDeclarations, fieldAndMethods, identifier, identifiers, methodDeclarations, parameters, 
parameterDeclarations, parameterDeclaration, statements, expressions, externinvk_args, conjunction, comparison, factor, term, sum,
relation;

non terminal Location location;
non terminal Expression expr;
non terminal AssignOpType assign_op;

/*DECLARACION DE VARIABLES TERMINALES */

/*Terminales palabras reservadas*/
terminal CLASS, ELSE, FALSE, ID, TRUE, VOID;
terminal IfStmt IF;
terminal BreakStmt BREAK;
terminal ContinueStmt CONTINUE;
terminal ForStmt FOR;
terminal ReturnStmt RETURN;
terminal WhileStmt WHILE;

/*Terminales operadores aritméticos y lógicos*/
terminal BinOpType SUMA, RESTA, MULTIPLICACION, DIVISION,  PORCENTAJE;
terminal AssignOpType ASIGNACION, INCREMENTO, DECREMENTO;

/*Terminales operadores lógicos*/
terminal BinOpType CONJUNCION, DISYUNCION, IGUALDAD_LOGICA, DIFERENCIA_LOGICA, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL;

/*Terminales signos de puntuación*/
terminal  COMA, PUNTO_Y_COMA, LLAVE_IZQ, LLAVE_DER, CORCHETE_IZQ, CORCHETE_DER, PARENTESIS_IZQ, PARENTESIS_DER, ADMIRACION; 

/*Terminales tipos*/
terminal INT, FLOAT, BOOLEAN;

/*Terminales varios*/
terminal EXTERNINVK;

/*Terminales objetos*/
terminal INT_LITERAL, FLOAT_LITERAL, STRING_LITERAL;

precedence left LLAVE_IZQ, LLAVE_DER;
precedence left CORCHETE_IZQ, CORCHETE_DER;
precedence right INCREMENTO;
precedence right DECREMENTO;
precedence right ASIGNACION;
precedence left DISYUNCION;
precedence left CONJUNCION;
precedence left DIFERENCIA_LOGICA, IGUALDAD_LOGICA;
precedence left MENOR_IGUAL, MAYOR_IGUAL;
precedence left MENOR, MAYOR;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, PORCENTAJE;
precedence left PARENTESIS_IZQ, PARENTESIS_DER;
precedence left ADMIRACION;

start with program;

program::= CLASS ID:d {: mainDeclared=false;  :} body {:if(mainDeclared){System.out.println("parseo exitoso");}else{System.out.println("Main Method Missing in Class "+d.toString());}:}
        ;

body::= LLAVE_IZQ LLAVE_DER 
    | LLAVE_IZQ {: TS = new symbolTable(); :} fieldAndMethods LLAVE_DER 
    ;

fieldAndMethods::= fieldDeclarations
               | methodDeclarations
               | fieldDeclarations methodDeclarations
               ;

fieldDeclarations::= field_decl
                 | fieldDeclarations field_decl
                 ;

field_decl::= type identifiers PUNTO_Y_COMA
          ;

identifiers::= identifier
            | identifiers COMA identifier
            ;

identifier::= ID:s {: TS.agregarSimbolo(tipo_corriente.toString(), s.toString(), null, 0); :} 
  | ID:s CORCHETE_IZQ INT_LITERAL:i CORCHETE_DER {: int size= Integer.valueOf((String) i); switch (tipo_corriente){
                                                       case INT:
                                                               TS.agregarSimbolo(Tipo.INTARRAY.toString(), s.toString(), null, size);  
                                                               break;
                                                       case FLOAT:
                                                               TS.agregarSimbolo(Tipo.FLOATARRAY.toString(), s.toString(), null, size);  
                                                               break;
                                                       case BOOLEAN:
                                                               TS.agregarSimbolo(Tipo.BOOLARRAY.toString(), s.toString(), null, size); 
                                                               break;
                                                                           }:} 
  ;

methodDeclarations::= method_decl
                  | methodDeclarations method_decl
                  ;

method_decl::= VOID ID:d {: if(d.toString().equals("main")){mainDeclared=true;} TS.agregarMetodo(Tipo.VOID.toString(), d.toString());:} parameters {:TS.agregarNivel();
                   Metodo e=TS.obtenerMetodo();
                   for(int i=0; i<e.getParametros().size(); i++){
                        Simbolo actual = e.getParametros().get(i);
                        TS.agregarSimbolo(actual.getType(), actual.getName(), actual.getValue(), actual.getSize());
                   }         :} block
           | type ID:g {:if(g.toString().equals("main")){mainDeclared=true;} switch (tipo_corriente){
                              case INT:
                                        TS.agregarMetodo(Tipo.INT.toString(), g.toString());
                                        ult_metodo=new Metodo(Tipo.INT.toString(), g.toString());
                                        break;
                              case FLOAT:
                                        TS.agregarMetodo(Tipo.FLOAT.toString(), g.toString());  
                                        break;
                              case BOOLEAN:
                                        TS.agregarMetodo(Tipo.BOOLEAN.toString(), g.toString()); 
                                        break;
                                                 }:} parameters {:Metodo e=TS.obtenerMetodo();
                   TS.agregarNivel();
                   for(int i=0; i<e.getParametros().size(); i++){
                        Simbolo actual = e.getParametros().get(i);
                        TS.agregarSimbolo(actual.getType(), actual.getName(), actual.getValue(), actual.getSize());
                   }         :} block
           ;

block::= LLAVE_IZQ LLAVE_DER
     | LLAVE_IZQ statements LLAVE_DER
     | LLAVE_IZQ fieldDeclarations LLAVE_DER
     | LLAVE_IZQ fieldDeclarations statements LLAVE_DER
     ;


parameters::= PARENTESIS_IZQ PARENTESIS_DER
          | PARENTESIS_IZQ parameterDeclarations PARENTESIS_DER
          ;
            

parameterDeclarations::= parameterDeclaration
                     | parameterDeclarations COMA parameterDeclaration
                     ;

parameterDeclaration::= type ID:a {: Simbolo sym = new Simbolo(tipo_corriente.toString(), a.toString(), null, 0); 
                                      TS.obtenerMetodo().addParametro(sym); :}
                    ;

statements::= statement
          | statements statement
          ;
                    
type::= INT {:tipo_corriente = Tipo.INT; :} 
    | FLOAT {:tipo_corriente = Tipo.FLOAT; :}
    | BOOLEAN {:tipo_corriente = Tipo.BOOLEAN; :}
    ;

statement::= location:l assign_op:ao expr:e PUNTO_Y_COMA {: AssignStmt a=new AssignStmt((Location)l, (AssignOpType) ao, (Expression) e); RESULT=a; :}
         | method_call PUNTO_Y_COMA
         | IF PARENTESIS_IZQ {: TS.agregarNivel(); :} expr PARENTESIS_DER block {: TS.SubirNivel(); :} else_block
         | FOR ID ASIGNACION expr COMA expr {: TS.agregarNivel(); :}  block {: TS.SubirNivel(); :}
         | WHILE expr {: TS.agregarNivel(); :}  block {: TS.SubirNivel(); :}
         | RETURN PUNTO_Y_COMA
         | RETURN expr PUNTO_Y_COMA
         | BREAK PUNTO_Y_COMA
         | CONTINUE PUNTO_Y_COMA
         | PUNTO_Y_COMA
         | {: TS.agregarNivel(); :}  block {: TS.SubirNivel(); :}
         ;

else_block::= ELSE {: TS.agregarNivel(); :} block {: TS.SubirNivel(); :} 
          |
          ;

assign_op::= ASIGNACION 
         | INCREMENTO 
         | DECREMENTO
         ;

method_call::= ID PARENTESIS_IZQ PARENTESIS_DER
           |  ID PARENTESIS_IZQ expressions PARENTESIS_DER
           |  EXTERNINVK PARENTESIS_IZQ STRING_LITERAL COMA type_or_void COMA externinvk_args PARENTESIS_DER
           |  EXTERNINVK PARENTESIS_IZQ STRING_LITERAL COMA type_or_void PARENTESIS_DER
           ;

type_or_void::= type
            | VOID
            ;

expressions::= expr
           | expressions COMA expr
           ;

externinvk_args::= externinvk_arg
               | externinvk_args COMA externinvk_arg 
               ;

externinvk_arg::= expr
              | STRING_LITERAL
              ;

location::= ID
        | ID CORCHETE_IZQ expr CORCHETE_DER
        ;

expr::= conjunction
    | expr DISYUNCION conjunction
    ;

conjunction::= comparison
           | conjunction CONJUNCION comparison
           ;

comparison::= relation
          | relation IGUALDAD_LOGICA relation
          | relation DIFERENCIA_LOGICA relation
          ;

relation::= sum
        | sum MENOR sum
        | sum MAYOR sum
        | sum MAYOR_IGUAL sum
        | sum MENOR_IGUAL sum
        ;

sum::= term
   | sum SUMA term
   | sum RESTA term
   ;

term::= factor
    | term MULTIPLICACION factor
    | term DIVISION factor
    | term PORCENTAJE factor
    ;

factor::= literal
      | ADMIRACION factor
      | RESTA factor
      ;


literal::= INT_LITERAL
       | FLOAT_LITERAL
       | bool_LITERAL
       | ID
       | ID CORCHETE_IZQ expr CORCHETE_DER
       | method_call
       | PARENTESIS_IZQ expr PARENTESIS_DER
       ;

bool_LITERAL::= TRUE {: RESULT = true;:} 
            | FALSE {: RESULT = false;:}
            ;

